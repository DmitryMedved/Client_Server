Client_Server. HW

1) Прочиать про клиент-серверную архитектуру

«Клиент — сервер» (англ. client–server) — вычислительная или сетевая архитектура, в которой задания или сетевая нагрузка распределены между поставщиками услуг, называемыми серверами, и заказчиками услуг, называемыми клиентами. Фактически клиент и сервер — это программное обеспечение. Обычно эти программы расположены на разных вычислительных машинах и взаимодействуют между собой через вычислительную сеть посредством сетевых протоколов, но они могут быть расположены также и на одной машине. Программы-серверы ожидают от клиентских программ запросы и предоставляют им свои ресурсы в виде данных (например, передача файлов посредством HTTP, FTP, BitTorrent, потоковое мультимедиа или работа с базами данных) или в виде сервисных функций (например, работа с электронной почтой, общение посредством систем мгновенного обмена сообщениями или просмотр web-страниц во всемирной паутине). Поскольку одна программа-сервер может выполнять запросы от множества программ-клиентов, её размещают на специально выделенной вычислительной машине, настроенной особым образом, как правило, совместно с другими программами-серверами, поэтому производительность этой машины должна быть высокой. Из-за особой роли такой машины в сети, специфики её оборудования и программного обеспечения, её также называют сервером, а машины, выполняющие клиентские программы, соответственно, клиентами.

Роль клиента и сервера
Характеристика клиент-сервер описывает отношения взаимодействующих программ в приложении. Серверный компонент предоставляет функцию или услугу одному или нескольким клиентам, которые инициируют запросы на такие услуги. Серверы классифицируются по предоставляемым ими услугам. Например, веб-сервер обслуживает веб-страницы, а файловый сервер обслуживает компьютерные файлы. Общий ресурс может быть любой из программного обеспечения и электронных компонентов компьютера — сервера, от программ и данных в процессорах и запоминающих устройств. Совместное использование ресурсов сервера представляет собой услугу.
Является ли компьютер клиентом, сервером или и тем, и другим, определяется характером приложения, которому требуются сервисные функции. Например, на одном компьютере могут одновременно работать веб-серверы и программное обеспечение файлового сервера, чтобы обслуживать разные данные для клиентов, отправляющих различные типы запросов. Клиентское программное обеспечение также может взаимодействовать с серверным программным обеспечением на том же компьютере. Связь между серверами, например, для синхронизации данных, иногда называется межсерверной.

Взаимодействие клиента и сервера
Вообще говоря, служба — это абстракция компьютерных ресурсов, и клиенту не нужно беспокоиться о том, как сервер работает при выполнении запроса и доставке ответа. Клиенту нужно только понять ответ, основанный на известном протоколе приложения, то есть содержание и форматирование данных для запрашиваемой услуги.
Клиенты и серверы обмениваются сообщениями в шаблоне запрос-ответ. Клиент отправляет запрос, а сервер возвращает ответ. Этот обмен сообщениями является примером межпроцессного взаимодействия. Для взаимодействия компьютеры должны иметь общий язык, и они должны следовать правилам, чтобы и клиент, и сервер знали, чего ожидать. Язык и правила общения определены в протоколе связи. Все протоколы клиент-серверной модели работают на уровне приложений. Протокол прикладного уровня определяет основные шаблоны диалога. Чтобы ещё больше формализовать обмен данными, сервер может реализовать интерфейс прикладного программирования (API). API — это уровень абстракции для доступа к сервису. Ограничивая связь определённым форматом контента, он облегчает синтаксический анализ. Абстрагируя доступ, он облегчает межплатформенный обмен данными.
Сервер может получать запросы от множества различных клиентов за короткий период времени. Компьютер может выполнять только ограниченное количество задач в любой момент и полагается на систему планирования для определения приоритетов входящих запросов от клиентов для их удовлетворения. Чтобы предотвратить злоупотребления и максимизировать доступность серверное программное обеспечение может ограничивать доступность для клиентов. Атаки типа «отказ в обслуживании» используют обязанности сервера обрабатывать запросы, такие атаки действуют путем перегрузки сервера чрезмерной частотой запросов. Шифрование следует применять, если между клиентом и сервером должна передаваться конфиденциальная информация.

Сравнение с peer-to-peer архитектурой
В дополнение к клиент-серверной модели распределенные вычислительные приложения часто используют peer-to-peer архитектуру.
Клиент-сервер часто проектируется как централизованная система, которая обслуживает множество клиентов. Таким образом, требования к мощности, памяти и объёму хранилища сервера должны масштабироваться с ожидаемой нагрузкой. Системы балансировки нагрузки и отказоустойчивости часто используются для масштабирования сервера за пределами одной физической машины. В одноранговой сети два или более компьютера объединяют свои ресурсы и взаимодействуют в децентрализованной системе. Одноранговые узлы — это равноправные или эквипотентные узлы в неиерархической сети. В отличие от клиентов в архитектуре клиент-сервер или клиент-очередь-клиент, одноранговые узлы взаимодействуют друг с другом напрямую. В одноранговой сети алгоритм в одноранговом коммуникационном протоколе балансирует нагрузку, и даже одноранговые узлы с небольшим количеством ресурсов могут помочь разделить нагрузку. Если узел становится недоступным, его общие ресурсы остаются доступными до тех пор, пока другие одноранговые узлы предлагают их. В идеале узлу не нужно достигать высокой доступности, поскольку другие узлы компенсируют любое время простоя ресурсов. По мере изменения доступности и пропускной способности одноранговых узлов протокол перенаправляет запросы. Как клиент-сервер, так и ведущий-ведомый рассматриваются как подкатегории распределенных одноранговых систем.

Преимущества
Отсутствие дублирования кода программы-сервера программами-клиентами.
Так как все вычисления выполняются на сервере, то требования к компьютерам, на которых установлен клиент, снижаются.
Все данные хранятся на сервере, который, как правило, защищён гораздо лучше большинства клиентов. На сервере проще организовать контроль полномочий, чтобы разрешать доступ к данным только клиентам с соответствующими правами доступа.

Недостатки
Неработоспособность сервера может сделать неработоспособной всю вычислительную сеть. Неработоспособным сервером следует считать сервер, производительности которого не хватает на обслуживание всех клиентов, а также сервер, находящийся на ремонте, профилактике и т. п.
Поддержка работы данной системы требует отдельного специалиста — системного администратора.
Высокая стоимость оборудования.

Многоуровневая архитектура «клиент — сервер»
Многоуровневая архитектура «клиент — сервер» — разновидность архитектуры «клиент — сервер», в которой функция обработки данных вынесена на несколько отдельных серверов. Это позволяет разделить функции хранения, обработки и представления данных для более эффективного использования возможностей серверов и клиентов.

Частные случаи многоуровневой архитектуры:
Трёху́ровневая архитекту́ра (трёхзве́нная архитекту́ра, англ. three-tier) — архитектурная модель программного комплекса, предполагающая наличие в нём трёх типов компонентов (уровней, звеньев): клиентских приложений (с которыми работают пользователи), серверов приложений (с которыми работают клиентские приложения) и серверов баз данных (с которыми работают серверы приложений).
Компоненты:
- Клиент (слой клиента) — это интерфейсный (обычно графический) компонент комплекса, предоставляемый конечному пользователю. Этот уровень не должен иметь прямых связей с базой данных (по требованиям безопасности и масштабируемости), быть нагруженным основной бизнес-логикой (по требованиям масштабируемости) и хранить состояние приложения (по требованиям надёжности). На этот уровень обычно выносится только простейшая бизнес-логика: интерфейс авторизации, алгоритмы шифрования, проверка вводимых значений на допустимость и соответствие формату, несложные операции с данными (сортировка, группировка, подсчёт значений), уже загруженными на терминал.
- Сервер приложений (средний слой, связующий слой) располагается на втором уровне, на нём сосредоточена бо́льшая часть бизнес-логики. Вне его остаются только фрагменты, экспортируемые на клиента (терминалы), а также элементы логики, погруженные в базу данных (хранимые процедуры и триггеры). Реализация данного компонента обеспечивается связующим программным обеспечением. Серверы приложений проектируются таким образом, чтобы добавление к ним дополнительных экземпляров обеспечивало горизонтальное масштабирование производительности программного комплекса и не требовало внесения изменений в программный код приложения.
- Сервер баз данных (слой данных) обеспечивает хранение данных и выносится на отдельный уровень, реализуется, как правило, средствами систем управления базами данных, подключение к этому компоненту обеспечивается только с уровня сервера приложений.

В простейших конфигурациях все компоненты или часть из них могут быть совмещены на одном вычислительном узле. В продуктивных конфигурациях как правило используется выделенный вычислительный узел для сервера баз данных или кластер серверов баз данных, для серверов приложений — выделенная группа вычислительных узлов, к которым непосредственно подключаются клиенты (терминалы).

Сравнение
По сравнению с двухзвенной клиент-серверной архитектурой или файл-серверной архитектурой трёхуровневая архитектура обеспечивает, как правило, бо́льшую масштабируемость (за счёт горизонтальной масштабируемости сервера приложений и мультиплексирования соединений), бо́льшую конфигурируемость (за счёт изолированности уровней друг от друга). Реализация приложений, доступных из веб-браузера или из тонкого клиента, как правило, подразумевает развёртывание программного комплекса в трёхуровневой архитектуре. При этом обычно разработка трёхзвенных программных комплексов сложнее, чем для двухзвенных, также наличие дополнительного связующего программного обеспечения может налагать дополнительные издержки в администрировании таких комплексов.

Сеть с выделенным сервером

Сеть с выделенным сервером (англ. client/server network) — это локальная вычислительная сеть (LAN), в которой сетевые устройства централизованы и управляются одним или несколькими серверами. Индивидуальные рабочие станции или клиенты (такие, как Персональный компьютер) должны обращаться к ресурсам сети через сервер(а).

Построение сети
Существуют способы классифицировать сеть. Основным критерием классификации принято считать способ администрирования. То есть в зависимости от того, как организована сеть и как она управляется, её можно отнести к локальной, распределённой, городской или глобальной сети. Управляет сетью или её сегментом сетевой администратор. В случае сложных сетей их права и обязанности строго распределены, ведётся документация и журналирование действий команды администраторов.

Компьютеры могут соединяться между собой, используя различные среды доступа: медные проводники (витая пара), оптические проводники (оптические кабели) и через радиоканал (беспроводные технологии). Проводные, оптические связи устанавливаются через Ethernet и прочие средства. Отдельная локальная вычислительная сеть может иметь связь с другими локальными сетями через шлюзы, а также быть частью глобальной вычислительной сети (например, Интернет) или иметь подключение к ней.

Чаще всего локальные сети построены на технологиях Ethernet. Следует отметить, что ранее использовались протоколы Frame Relay, Token ring, которые на сегодняшний день встречаются всё реже, их можно увидеть лишь в специализированных лабораториях, учебных заведениях и службах. Для построения простой локальной сети используются маршрутизаторы, коммутаторы, точки беспроводного доступа, беспроводные маршрутизаторы, модемы и сетевые адаптеры. Реже используются преобразователи (конвертеры) среды, усилители сигнала (повторители разного рода) и специальные антенны.

Маршрутизация в локальных сетях используется примитивная, если она вообще необходима. Чаще всего это статическая либо динамическая маршрутизация (основанная на протоколе RIP).

Иногда в локальной сети организуются рабочие группы — формальное объединение нескольких компьютеров в группу с единым названием.

Сетевой администратор — человек, ответственный за работу локальной сети или её части. В его обязанности входит обеспечение и контроль физической связи, настройка активного оборудования, настройка общего доступа и предопределённого круга программ, обеспечивающих стабильную работу сети.

Технологии локальных сетей реализуют, как правило, функции только двух нижних уровней модели OSI — физического и канального. Функциональности этих уровней достаточно для доставки кадров в пределах стандартных топологий, которые поддерживают LAN: звезда, общая шина, кольцо и дерево. Однако из этого не следует, что компьютеры, связанные в локальную сеть, не поддерживают протоколы уровней, расположенных выше канального. Эти протоколы также устанавливаются и работают на узлах локальной сети, но выполняемые ими функции не относятся к технологии LAN.

2) Что такое HTTP и HTTP

HTTP (англ. HyperText Transfer Protocol — «протокол передачи гипертекста») — протокол прикладного уровня передачи данных, изначально — в виде гипертекстовых документов в формате HTML, в настоящее время используется для передачи произвольных данных.

Основные свойства
Основой HTTP является технология «клиент-сервер», то есть предполагается существование:
- Потребителей (клиентов), которые инициируют соединение и посылают запрос;
- Поставщиков (серверов), которые ожидают соединения для получения запроса, производят необходимые действия и возвращают обратно сообщение с результатом.
HTTP в настоящее время повсеместно используется во Всемирной паутине для получения информации с веб-сайтов. 
HTTP используется также в качестве «транспорта» для других протоколов прикладного уровня, таких как SOAP, XML-RPC, WebDAV.

Основным объектом манипуляции в HTTP является ресурс, на который указывает URI (Uniform Resource Identifier) в запросе клиента. Обычно такими ресурсами являются хранящиеся на сервере файлы, но ими могут быть логические объекты или что-то абстрактное. Особенностью протокола HTTP является возможность указать в запросе и ответе способ представления одного и того же ресурса по различным параметрам: формату, кодировке, языку и т. д. (в частности, для этого используется HTTP-заголовок). Именно благодаря возможности указания способа кодирования сообщения клиент и сервер могут обмениваться двоичными данными, хотя данный протокол является текстовым.

HTTP — протокол прикладного уровня; аналогичными ему являются FTP и SMTP. Обмен сообщениями идёт по обыкновенной схеме «запрос-ответ». Для идентификации ресурсов HTTP использует глобальные URI. В отличие от многих других протоколов, HTTP не сохраняет своего состояния. Это означает отсутствие сохранения промежуточного состояния между парами «запрос-ответ». Компоненты, использующие HTTP, могут самостоятельно осуществлять сохранение информации о состоянии, связанной с последними запросами и ответами (например, «куки» на стороне клиента, «сессии» на стороне сервера). Браузер, посылающий запросы, может отслеживать задержки ответов. Сервер может хранить IP-адреса и заголовки запросов последних клиентов. Однако сам протокол не осведомлён о предыдущих запросах и ответах, в нём не предусмотрена внутренняя поддержка состояния, к нему не предъявляются такие требования.

Большинство протоколов предусматривает установление TCP-сессии, в ходе которой один раз происходит авторизация, и дальнейшие действия выполняются в контексте этой авторизации. HTTP же устанавливает отдельную TCP-сессию на каждый запрос; в более поздних версиях HTTP было разрешено делать несколько запросов в ходе одной TCP-сессии, но браузеры обычно запрашивают только страницу и включённые в неё объекты (картинки, каскадные стили и т. п.), а затем сразу разрывают TCP-сессию. Для поддержки авторизованного (неанонимного) доступа в HTTP используются cookies; причём такой способ авторизации позволяет сохранить сессию даже после перезагрузки клиента и сервера.

При доступе к данным по FTP или по файловым протоколам тип файла (точнее, тип содержащихся в нём данных) определяется по расширению имени файла, что не всегда удобно. HTTP перед тем, как передать сами данные, передаёт заголовок «Content-Type: тип/подтип», позволяющий клиенту однозначно определить, каким образом обрабатывать присланные данные. Это особенно важно при работе с CGI-скриптами, когда расширение имени файла указывает не на тип присылаемых клиенту данных, а на необходимость запуска данного файла на сервере и отправки клиенту результатов работы программы, записанной в этом файле (при этом один и тот же файл в зависимости от аргументов запроса и своих собственных соображений может порождать ответы разных типов — в простейшем случае картинки в разных форматах).

Кроме того, HTTP позволяет клиенту прислать на сервер параметры, которые будут переданы запускаемому CGI-скрипту. Для этого же в HTML были введены формы.

Перечисленные особенности HTTP позволили создавать поисковые машины (первой из которых стала AltaVista, созданная фирмой DEC), форумы и Internet-магазины. Это коммерциализировало Интернет, появились компании, основным полем деятельности которых стало предоставление доступа в Интернет (провайдеры) и создание сайтов.

Программное обеспечение
Всё программное обеспечение для работы с протоколом HTTP разделяется на три большие категории:
- Серверы как основные поставщики услуг хранения и обработки информации (обработка запросов);
- Клиенты — конечные потребители услуг сервера (отправка запроса);
- Прокси (посредники) для выполнения транспортных служб.

Для отличия конечных серверов от прокси в официальной документации используется термин «исходный сервер» (англ. origin server). Один и тот же программный продукт может одновременно выполнять функции клиента, сервера или посредника в зависимости от поставленных задач. В спецификациях протокола HTTP подробно описывается поведение для каждой из этих ролей.

Клиенты
Первоначально протокол HTTP разрабатывался для доступа к гипертекстовым документам Всемирной паутины. Поэтому основными реализациями клиентов являются браузеры (агенты пользователя). Для просмотра сохранённого содержимого сайтов на компьютере без соединения с Интернетом были придуманы офлайн-браузеры. При нестабильном соединении для загрузки больших файлов используются менеджеры закачек; они позволяют в любое время докачать указанные файлы после потери соединения с веб-сервером. Некоторые виртуальные атласы (такие как Google Планета Земля и NASA World Wind) тоже используют HTTP.

Исходные серверы
Основные реализации: Apache, Internet Information Services (IIS), nginx, LiteSpeed Web Server[en] (LSWS), Google Web Server, lighttpd.

Прокси-серверы
Основные реализации: Squid, UserGate, Multiproxy, Naviscope, nginx.

Структура HTTP-сообщения
Каждое HTTP-сообщение состоит из трёх частей, которые передаются в указанном порядке:
- Стартовая строка (англ. Starting line) — определяет тип сообщения;
- Заголовки (англ. Headers) — характеризуют тело сообщения, параметры передачи и прочие сведения;
- Тело сообщения (англ. Message Body) — непосредственно данные сообщения. Обязательно должно отделяться от заголовков пустой строкой.

Тело сообщения может отсутствовать, но стартовая строка и заголовок являются обязательными элементами. Исключением является версия 0.9 протокола, у которой сообщение запроса содержит только стартовую строку, а сообщения ответа — только тело сообщения.
Для версии протокола 1.1 сообщение запроса обязательно должно содержать заголовок Host.

Стартовая строка
Стартовые строки различаются для запроса и ответа. Строка запроса выглядит так:

GET URI — для версии протокола 0.9;
Метод URI HTTP/Версия — для остальных версий.

Здесь:
- Метод (англ. Method) — тип запроса, одно слово заглавными буквами. В версии HTTP 0.9 использовался только метод GET, список методов для версии 1.1 представлен ниже.
- URI определяет путь к запрашиваемому документу.
- Версия (англ. Version) — пара разделённых точкой цифр. Например: 1.0.

Чтобы запросить страницу данной статьи, клиент должен передать строку (задан всего один заголовок):
GET /wiki/HTTP HTTP/1.0
Host: ru.wikipedia.org

Стартовая строка ответа сервера имеет следующий формат: HTTP/Версия КодСостояния Пояснение, где:
- Версия — пара разделённых точкой цифр, как в запросе;
- Код состояния (англ. Status Code) — три цифры. По коду состояния определяется дальнейшее содержимое сообщения и поведение клиента;
Пояснение (англ. Reason Phrase) — текстовое короткое пояснение к коду ответа для пользователя. Никак не влияет на сообщение и является необязательным.

Например, стартовая строка ответа сервера на предыдущий запрос может выглядеть так:
HTTP/1.0 200 OK


HTTPS

HTTPS (аббр. от англ. HyperText Transfer Protocol Secure) — расширение протокола HTTP для поддержки шифрования в целях повышения безопасности. Данные в протоколе HTTPS передаются поверх криптографических протоколов TLS или устаревшего в 2015 году SSL. В отличие от HTTP с TCP-портом 80, для HTTPS по умолчанию используется TCP-порт 443.

Протокол был разработан компанией Netscape Communications для браузера Netscape Navigator в 1994 году.

Принцип работы
HTTPS не является отдельным протоколом. Это обычный HTTP, работающий через шифрованные транспортные механизмы SSL и TLS. Он обеспечивает защиту от атак, основанных на прослушивании сетевого соединения — от снифферских атак и атак типа man-in-the-middle, при условии, что будут использоваться шифрующие средства и сертификат сервера проверен и ему доверяют.

По умолчанию HTTPS URL использует 443 TCP-порт (для незащищённого HTTP — 80). Чтобы подготовить веб-сервер для обработки https-соединений, администратор должен получить и установить в систему сертификат открытого и закрытого ключа для этого веб-сервера. В TLS используется как асимметричная схема шифрования (для выработки общего секретного ключа), так и симметричная (для обмена данными, зашифрованными общим ключом). Сертификат открытого ключа подтверждает принадлежность данного открытого ключа владельцу сайта. Сертификат открытого ключа и сам открытый ключ посылаются клиенту при установлении соединения; закрытый ключ используется для расшифровки сообщений от клиента.

Существует возможность создать такой сертификат, не обращаясь в центр сертификации. Подписываются такие сертификаты этим же сертификатом и называются самоподписанными (self-signed). Без проверки сертификата каким-то другим способом (например, звонок владельцу и проверка контрольной суммы сертификата) такое использование HTTPS подвержено атаке посредника.

Эта система также может использоваться для аутентификации клиента, чтобы обеспечить доступ к серверу только авторизованным пользователям. Для этого администратор обычно создаёт сертификаты для каждого пользователя и загружает их в браузер каждого пользователя. Также будут приниматься все сертификаты, подписанные организациями, которым доверяет сервер. Такой сертификат обычно содержит имя и адрес электронной почты авторизованного пользователя, которые проверяются при каждом соединении, чтобы проверить личность пользователя без ввода пароля.

В HTTPS для шифрования используется длина ключа 40, 56, 128 или 256 бит. Некоторые старые версии браузеров используют длину ключа 40 бит (пример тому — IE версий до 4.0), что связано с экспортными ограничениями в США. Длина ключа 40 бит не является надёжной. Многие современные сайты требуют использования новых версий браузеров, поддерживающих шифрование с длиной ключа 128 бит, с целью обеспечить достаточный уровень безопасности. Шифрование с длиной ключа 128 бит значительно затрудняет подбор паролей и доступ к личной информации.

Традиционно на одном IP-адресе может работать только один HTTPS-сайт. Для работы нескольких HTTPS-сайтов с различными сертификатами применяется расширение TLS под названием Server Name Indication (SNI).

Идентификация в HTTPS
Идентификация сервера
HTTP/TLS запросы генерируются путём разыменования URI, вследствие чего имя хоста становится известно клиенту. В начале общения, сервер посылает клиенту свой сертификат, чтобы клиент идентифицировал его. Это позволяет предотвратить атаку посредника. В сертификате указывается URI сервера. Согласование имени хоста и данных, указанных в сертификате, происходит в соответствии с протоколом RFC2459.

Если имя сервера не совпадает с указанным в сертификате, то пользовательские программы, например браузеры, сообщают об этом пользователю. В основном, браузеры предоставляют пользователю выбор: продолжить незащищённое соединение или прервать его.

Идентификация клиента
Обычно сервер не располагает информацией о клиенте, достаточной для его идентификации. Однако для обеспечения повышенной защищённости соединения используется так называемая two-way authentication. При этом сервер после подтверждения его сертификата клиентом также запрашивает сертификат. Таким образом, схема подтверждения клиента аналогична идентификации сервера[14].

Уязвимости HTTPS
Совместное использование HTTP и HTTPS
Когда сайты используют смешанную функциональность HTTP и HTTPS, это потенциально приводит к информационной угрозе для пользователя. Например, если основные страницы некоторого сайта загружаются, используя HTTPS, а CSS и JavaScript загружаются по HTTP, то злоумышленник в момент загрузки последних может подгрузить свой код и получить данные HTML-страницы. Многие сайты, несмотря на такие уязвимости, загружают контент через сторонние сервисы, которые не поддерживают HTTPS. Механизм HSTS позволяет предотвратить подобные уязвимости, заставляя принудительно использовать HTTPS соединение даже там, где по умолчанию используется HTTP.

3) HTTP методы

Метод HTTP (англ. HTTP Method) — последовательность из любых символов, кроме управляющих и разделителей, указывающая на основную операцию над ресурсом. Обычно метод представляет собой короткое английское слово, записанное заглавными буквами. Обратите внимание, что название метода чувствительно к регистру. Сервер может использовать любые методы, не существует обязательных методов для сервера или клиента. 

OPTIONS
Используется для определения возможностей веб-сервера или параметров соединения для конкретного ресурса. В ответ серверу следует включить заголовок Allow со списком поддерживаемых методов. Также в заголовке ответа может включаться информация о поддерживаемых расширениях. 
Предполагается, что запрос клиента может содержать тело сообщения для указания интересующих его сведений. Формат тела и порядок работы с ним в настоящий момент не определён; сервер пока должен его игнорировать. Аналогичная ситуация и с телом в ответе сервера.
Для того, чтобы узнать возможности всего сервера, клиент должен указать в URI звёздочку — «*». Запросы «OPTIONS * HTTP/1.1» могут также применяться для проверки работоспособности сервера (аналогично «пингованию») и тестирования на предмет поддержки сервером протокола HTTP версии 1.1.
Результат выполнения этого метода не кэшируется.

GET
Используется для запроса содержимого указанного ресурса. С помощью метода GET можно также начать какой-либо процесс. В этом случае в тело ответного сообщения следует включить информацию о ходе выполнения процесса.
Клиент может передавать параметры выполнения запроса в URI целевого ресурса после символа «?»:
GET /path/resource?param1=value1&param2=value2 HTTP/1.1
Согласно стандарту HTTP, запросы типа GET считаются идемпотентными[2]
Кроме обычного метода GET, различают ещё
Условный GET — содержит заголовки If-Modified-Since, If-Match, If-Range и подобные;
Частичный GET — содержит в запросе Range.
Порядок выполнения подобных запросов определён стандартами отдельно.

HEAD
Аналогичен методу GET, за исключением того, что в ответе сервера отсутствует тело. Запрос HEAD обычно применяется для извлечения метаданных, проверки наличия ресурса (валидация URL) и чтобы узнать, не изменился ли он с момента последнего обращения.
Заголовки ответа могут кэшироваться. При несовпадении метаданных ресурса с соответствующей информацией в кэше — копия ресурса помечается как устаревшая.

POST
Применяется для передачи пользовательских данных заданному ресурсу. Например, в блогах посетители обычно могут вводить свои комментарии к записям в HTML-форму, после чего они передаются серверу методом POST и он помещает их на страницу. При этом передаваемые данные (в примере с блогами — текст комментария) включаются в тело запроса. Аналогично с помощью метода POST обычно загружаются файлы на сервер.
В отличие от метода GET, метод POST не считается идемпотентным, то есть многократное повторение одних и тех же запросов POST может возвращать разные результаты (например, после каждой отправки комментария будет появляться очередная копия этого комментария).
При результате выполнения 200 (Ok) в тело ответа следует включить сообщение об итоге выполнения запроса. Если был создан ресурс, то серверу следует вернуть ответ 201 (Created) с указанием URI нового ресурса в заголовке Location.
Сообщение ответа сервера на выполнение метода POST не кэшируется.

PUT
Применяется для загрузки содержимого запроса на указанный в запросе URI. Если по заданному URI не существует ресурса, то сервер создаёт его и возвращает статус 201 (Created). Если же ресурс был изменён, то сервер возвращает 200 (Ok) или 204 (No Content). Сервер не должен игнорировать некорректные заголовки Content-*, передаваемые клиентом вместе с сообщением. Если какой-то из этих заголовков не может быть распознан или недопустим при текущих условиях, то необходимо вернуть код ошибки 501 (Not Implemented).
Фундаментальное различие методов POST и PUT заключается в понимании предназначений URI ресурсов. Метод POST предполагает, что по указанному URI будет производиться обработка передаваемого клиентом содержимого. Используя PUT, клиент предполагает, что загружаемое содержимое соответствует находящемуся по данному URI ресурсу.
Сообщения ответов сервера на метод PUT не кэшируются.

PATCH
Аналогично PUT, но применяется только к фрагменту ресурса.

DELETE
Удаляет указанный ресурс.

TRACE
Возвращает полученный запрос так, что клиент может увидеть, какую информацию промежуточные серверы добавляют или изменяют в запросе.

CONNECT
Преобразует соединение запроса в прозрачный TCP/IP-туннель, обычно чтобы содействовать установлению защищённого SSL-соединения через нешифрованный прокси.

4) HTTP статус коды сервера

Код состояния HTTP (англ. HTTP status code) — часть первой строки ответа сервера при запросах по протоколу HTTP. Он представляет собой целое трёхразрядное десятичное число. Первая цифра указывает на класс состояния. За кодом ответа обычно следует отделённая пробелом поясняющая фраза на английском языке, которая разъясняет человеку причину именно такого ответа. 

Примеры:
201 Created.
401 Unauthorized.
507 Insufficient Storage.

Клиент узнаёт по коду ответа о результатах своего запроса и определяет, какие действия ему предпринимать дальше. Набор кодов состояния является стандартом, и они описаны в соответствующих документах RFC. Введение новых кодов должно производиться только после согласования с IETF. Тем не менее известно о двух используемых кодах, не упомянутых в RFC: 449 Retry With. Также упоминается пояснительная фраза «Reply With» в спецификации по WebDAV в Microsoft Developer Network, введённый Microsoft, и 509 Bandwidth Limit Exceeded, введённый в cPanel.

Клиент может не знать все коды состояния, но он обязан отреагировать в соответствии с классом кода. В настоящее время выделено пять классов кодов состояния:

Информационные
В этот класс выделены коды, информирующие о процессе передачи. При работе через протокол версии 1.0 сообщения с такими кодами должны игнорироваться. В версии 1.1 клиент должен быть готов принять этот класс сообщений как обычный ответ, но серверу отправлять что-либо не нужно. Сами сообщения от сервера содержат только стартовую строку ответа и, если требуется, несколько специфичных для ответа полей заголовка. Прокси-серверы подобные сообщения должны отправлять дальше от сервера к клиенту.
100 Continue — сервер удовлетворён начальными сведениями о запросе, клиент может продолжать пересылать заголовки. Появился в HTTP/1.1.
101 Switching Protocols — сервер выполняет требование клиента и переключает протоколы в соответствии с указанием, данным в поле заголовка Upgrade. Сервер отправляет заголовок ответа Upgrade, указывая протокол, на который он переключился. Появился в HTTP/1.1.
102 Processing — запрос принят, но на его обработку понадобится длительное время. Используется сервером, чтобы клиент не разорвал соединение из-за превышения времени ожидания. Клиент при получении такого ответа должен сбросить таймер и дожидаться следующей команды в обычном режиме. Появился в WebDAV.
103 Early Hints — используется для раннего возврата части заголовков, когда заголовки полного ответа не могут быть быстро сформированы.

Успех
Сообщения данного класса информируют о случаях успешного принятия и обработки запроса клиента. В зависимости от статуса сервер может ещё передать заголовки и тело сообщения.
200 OK — успешный запрос. Если клиентом были запрошены какие-либо данные, то они находятся в заголовке и/или теле сообщения. Появился в HTTP/1.0.
201 Created — в результате успешного выполнения запроса был создан новый ресурс. Сервер может указать адреса (их может быть несколько) созданного ресурса в теле ответа, при этом предпочтительный адрес указывается в заголовке Location. Серверу рекомендуется указывать в теле ответа характеристики созданного ресурса и его адреса, формат тела ответа определяется заголовком Content-Type. При обработке запроса новый ресурс должен быть создан до отправки ответа клиенту, иначе следует использовать ответ с кодом 202. Появился в HTTP/1.0.
202 Accepted — запрос был принят на обработку, но она не завершена. Клиенту не обязательно дожидаться окончательной передачи сообщения, так как может быть начат очень долгий процесс. Появился в HTTP/1.0.
203 Non-Authoritative Information — аналогично ответу 200, но в этом случае передаваемая информация была взята не из первичного источника (резервной копии, другого сервера и т. д.) и поэтому может быть неактуальной. Появился в HTTP/1.1.
204 No Content — сервер успешно обработал запрос, но в ответе были переданы только заголовки без тела сообщения. Клиент не должен обновлять содержимое документа, но может применить к нему полученные метаданные. Появился в HTTP/1.0.
205 Reset Content — сервер обязывает клиента сбросить введённые пользователем данные. Тела сообщения сервер при этом не передаёт и документ обновлять не обязательно. Появился в HTTP/1.1.
206 Partial Content — сервер удачно выполнил частичный GET-запрос, возвратив только часть сообщения. В заголовке Content-Range сервер указывает байтовые диапазоны содержимого. Особое внимание при работе с подобными ответами следует уделить кэшированию. Появился в HTTP/1.1. (подробнее…)
207 Multi-Status — сервер передаёт результаты выполнения сразу нескольких независимых операций. Они помещаются в само тело сообщения в виде XML-документа с объектом multistatus. Не рекомендуется размещать в этом объекте статусы из серии 1xx из-за бессмысленности и избыточности. Появился в WebDAV.
208 Already Reported — члены привязки DAV уже были перечислены в предыдущей части (multistatus) ответа и не включаются снова.
226 IM Used — заголовок A-IM от клиента был успешно принят и сервер возвращает содержимое с учётом указанных параметров. Введено в RFC 3229 для дополнения протокола HTTP поддержкой дельта-кодирования.

Перенаправление
Коды этого класса сообщают клиенту, что для успешного выполнения операции необходимо сделать другой запрос, как правило, по другому URI. Из данного класса пять кодов 301, 302, 303, 305 и 307 относятся непосредственно к перенаправлениям. Адрес, по которому клиенту следует произвести запрос, сервер указывает в заголовке Location. При этом допускается использование фрагментов в целевом URI.
По последним стандартам клиент может производить перенаправление без запроса пользователя только если второй ресурс будет запрашиваться методом GET или HEAD. В предыдущих спецификациях говорилось, что для избежания круговых переходов пользователя следует спрашивать после 5-го подряд перенаправления. При всех перенаправлениях, если метод запроса был не HEAD, то в тело ответа следует включить короткое гипертекстовое сообщение с целевым адресом, чтобы в случае ошибки пользователь смог сам произвести переход.
Разработчики HTTP отмечают, что многие клиенты при перенаправлениях с кодами 301 и 302 ошибочно применяют метод GET ко второму ресурсу, несмотря на то, что к первому запрос был с иным методом (чаще всего PUT). Чтобы избежать недоразумений, в версии HTTP/1.1 были введены коды 303 и 307 и их рекомендовано использовать вместо 302. Изменять метод нужно только если сервер ответил 303. В остальных случаях следующий запрос производить с исходным методом.

Ошибка клиента
Класс кодов 4xx предназначен для указания ошибок со стороны клиента. При использовании всех методов, кроме HEAD, сервер должен вернуть в теле сообщения гипертекстовое пояснение для пользователя.
400 Bad Request — сервер обнаружил в запросе клиента синтаксическую ошибку. Появился в HTTP/1.0.
401 Unauthorized — для доступа к запрашиваемому ресурсу требуется аутентификация. В заголовке ответ должен содержать поле WWW-Authenticate с перечнем условий аутентификации. Иными словами, для доступа к запрашиваемому ресурсу клиент должен представиться, послав запрос, включив при этом в заголовок сообщения поле Authorization с требуемыми для аутентификации данными. Если запрос уже включает данные для авторизации, ответ 401 означает, что в авторизации с ними отказано.
402 Payment Required — предполагается использовать в будущем[когда?]. В настоящий момент[когда?] не используется. Этот код предусмотрен для платных пользовательских сервисов, а не для хостинговых компаний. Имеется в виду, что эта ошибка не будет выдана хостинговым провайдером в случае просроченной оплаты его услуг. Зарезервирован, начиная с HTTP/1.1.
Сервер вернул ошибку 403 при попытке просмотра каталога «cgi-bin», доступ к которому был запрещён
403 Forbidden — сервер понял запрос, но он отказывается его выполнять из-за ограничений в доступе для клиента к указанному ресурсу. Иными словами, клиент не уполномочен совершать операции с запрошенным ресурсом. Если для доступа к ресурсу требуется аутентификация средствами HTTP, то сервер вернёт ответ 401, или 407 при использовании прокси. В противном случае ограничения были заданы администратором сервера или разработчиком веб-приложения и могут быть любыми в зависимости от возможностей используемого программного обеспечения. В любом случае серверу следует сообщить причины отказа в обработке запроса. Наиболее вероятными причинами ограничения может послужить попытка доступа к системным ресурсам веб-сервера (например, файлам .htaccess или .htpasswd) или к файлам, доступ к которым был закрыт с помощью конфигурационных файлов, требование аутентификации не средствами HTTP, например, для доступа к системе управления содержимым или разделу для зарегистрированных пользователей либо сервер не удовлетворён IP-адресом клиента, например, при блокировках. Появился в HTTP/1.0.
404 Not Found[20] — самая распространённая ошибка при пользовании Интернетом, основная причина — ошибка в написании адреса Web-страницы. Сервер понял запрос, но не нашёл соответствующего ресурса по указанному URL. Если серверу известно, что по этому адресу был документ, то ему желательно использовать код 410. Ответ 404 может использоваться вместо 403, если требуется тщательно скрыть от посторонних глаз определённые ресурсы. Появился в HTTP/1.0.
405 Method Not Allowed — указанный клиентом метод нельзя применить к текущему ресурсу. В ответе сервер должен указать доступные методы в заголовке Allow, разделив их запятой. Эту ошибку сервер должен возвращать, если метод ему известен, но он не применим именно к указанному в запросе ресурсу, если же указанный метод не применим на всём сервере, то клиенту нужно вернуть код 501 (Not Implemented). Появился в HTTP/1.1.
406 Not Acceptable — запрошенный URI не может удовлетворить переданным в заголовке характеристикам. Если метод был не HEAD, то сервер должен вернуть список допустимых характеристик для данного ресурса. Появился в HTTP/1.1.
407 Proxy Authentication Required — ответ аналогичен коду 401 за исключением того, что аутентификация производится для прокси-сервера. Механизм аналогичен идентификации на исходном сервере. Появился в HTTP/1.1.
408 Request Timeout — время ожидания сервером передачи от клиента истекло. Клиент может повторить аналогичный предыдущему запрос в любое время. Например, такая ситуация может возникнуть при загрузке на сервер объёмного файла методом POST или PUT. В какой-то момент передачи источник данных перестал отвечать, например, из-за повреждения компакт-диска или потери связи с другим компьютером в локальной сети. Пока клиент ничего не передаёт, ожидая от него ответа, соединение с сервером держится. Через некоторое время сервер может закрыть соединение со своей стороны, чтобы дать возможность другим клиентам сделать запрос. Этот ответ не возвращается, когда клиент принудительно остановил передачу по команде пользователя или соединение прервалось по каким-то иным причинам, так как ответ уже послать невозможно. Появился в HTTP/1.1.
409 Conflict — запрос не может быть выполнен из-за конфликтного обращения к ресурсу. Такое возможно, например, когда два клиента пытаются изменить ресурс с помощью метода PUT. Появился в HTTP/1.1.
410 Gone — такой ответ сервер посылает, если ресурс раньше был по указанному URL, но был удалён и теперь недоступен. Серверу в этом случае неизвестно и местоположение альтернативного документа (например копии). Появился в HTTP/1.1.
411 Length Required — для указанного ресурса клиент должен указать Content-Length в заголовке запроса. Без указания этого поля не стоит делать повторную попытку запроса к серверу по данному URI. Такой ответ естественен для запросов типа POST и PUT. Например, если по указанному URI производится загрузка файлов, а на сервере стоит ограничение на их объём. Тогда разумней будет проверить в самом начале заголовок Content-Length и сразу отказать в загрузке, чем провоцировать бессмысленную нагрузку, разрывая соединение, когда клиент действительно пришлёт слишком объёмное сообщение. Появился в HTTP/1.1.
412 Precondition Failed — возвращается, если ни одно из условных полей заголовка (If-Match и др., см. RFC 7232) запроса не было выполнено. Появился в HTTP/1.1.
413 Payload Too Large — возвращается в случае, если сервер отказывается обработать запрос по причине слишком большого размера тела запроса. Сервер может закрыть соединение, чтобы прекратить дальнейшую передачу запроса. Если проблема временная, то рекомендуется в ответ сервера включить заголовок Retry-After с указанием времени, по истечении которого можно повторить аналогичный запрос. Появился в HTTP/1.1. Ранее назывался «Request Entity Too Large».
414 URI Too Long — сервер не может обработать запрос из-за слишком длинного указанного URI. Такую ошибку можно спровоцировать, например, когда клиент пытается передать длинные параметры через метод GET, а не POST. Появился в HTTP/1.1. Ранее назывался «Request-URI Too Long».
415 Unsupported Media Type — по каким-то причинам сервер отказывается работать с указанным типом данных при данном методе. Появился в HTTP/1.1.
416 Range Not Satisfiable — в поле Range заголовка запроса был указан диапазон за пределами ресурса и отсутствует поле If-Range. Если клиент передал байтовый диапазон, то сервер может вернуть реальный размер в поле Content-Range заголовка. Данный ответ не следует использовать при передаче типа multipart/byteranges[источник не указан 3726 дней]. Введено в RFC 2616 (обновление HTTP/1.1). Ранее назывался «Requested Range Not Satisfiable».
417 Expectation Failed — по каким-то причинам сервер не может удовлетворить значению поля Expect заголовка запроса. Введено в RFC 2616 (обновление HTTP/1.1).
418 I’m a teapot — Этот код был введен в 1998 году как одна из традиционных первоапрельских шуток IETF в RFC 2324, Hyper Text Coffee Pot Control Protocol. Не ожидается, что данный код будет поддерживаться реальными серверами[21].
419 Authentication Timeout (not in RFC 2616) — Этого кода нет в RFC 2616, используется в качестве альтернативы коду 401, которые прошли проверку подлинности, но лишены доступа к определенным ресурсам сервера. Обычно код отдается, если CSRF-токен устарел или оказался некорректным.
421 Misdirected Request — запрос был перенаправлен на сервер, не способный дать ответ.
422 Unprocessable Entity — сервер успешно принял запрос, может работать с указанным видом данных (например, в теле запроса находится XML-документ, имеющий верный синтаксис), однако имеется какая-то логическая ошибка, из-за которой невозможно произвести операцию над ресурсом. Введено в WebDAV.
423 Locked — целевой ресурс из запроса заблокирован от применения к нему указанного метода. Введено в WebDAV.
424 Failed Dependency — реализация текущего запроса может зависеть от успешности выполнения другой операции. Если она не выполнена и из-за этого нельзя выполнить текущий запрос, то сервер вернёт этот код. Введено в WebDAV.
425 Too Early — сервер не готов принять риски обработки "ранней информации". Введено в RFC 8470 для защиты от атак повторения при использовании 0-RTT в TLS 1.3.
426 Upgrade Required — сервер указывает клиенту на необходимость обновить протокол. Заголовок ответа должен содержать правильно сформированные поля Upgrade и Connection. Введено в RFC 2817 для возможности перехода к TLS посредством HTTP.
428 Precondition Required — сервер указывает клиенту на необходимость использования в запросе заголовков условий, наподобие If-Match. Введено в черновике стандарта RFC 6585.
429 Too Many Requests — клиент попытался отправить слишком много запросов за короткое время, что может указывать, например, на попытку DDoS-атаки. Может сопровождаться заголовком Retry-After, указывающим, через какое время можно повторить запрос. Введено в черновике стандарта RFC 6585.
431 Request Header Fields Too Large — Превышена допустимая длина заголовков. Сервер не обязан отвечать этим кодом, вместо этого он может просто сбросить соединение. Введено в черновике стандарта RFC 6585.
434 Requested host unavailable — Запрашиваемый адрес недоступен[источник не указан 3163 дня].
449 Retry With — возвращается сервером, если для обработки запроса от клиента поступило недостаточно информации. При этом в заголовок ответа помещается поле Ms-Echo-Request. Введено корпорацией Microsoft для WebDAV. В настоящий момент[когда?] используется как минимум программой Microsoft Money.
451 Unavailable For Legal Reasons — доступ к ресурсу закрыт по юридическим причинам, например, по требованию органов государственной власти или по требованию правообладателя в случае нарушения авторских прав. Введено в черновике IETF за авторством Google[12], при этом код ошибки является отсылкой к роману Рэя Брэдбери «451 градус по Фаренгейту». Был добавлен в стандарт 21 декабря 2015 года[22].
499 Client Closed Request — нестандартный код, предложенный и используемый nginx для случаев, когда клиент закрыл соединение, пока nginx обрабатывал запрос.

Ошибка сервера
Пример ошибки 502 Bad Gateway
Коды 5xx выделены под случаи необработанных исключений при выполнении операций на стороне сервера. Для всех ситуаций, кроме использования метода HEAD, сервер должен включать в тело сообщения объяснение, которое клиент отобразит пользователю.
500 Internal Server Error[23] — любая внутренняя ошибка сервера, которая не входит в рамки остальных ошибок класса. Появился в HTTP/1.0.
501 Not Implemented — сервер не поддерживает возможностей, необходимых для обработки запроса. Типичный ответ для случаев, когда сервер не понимает указанный в запросе метод. Если же метод серверу известен, но он не применим к данному ресурсу, то нужно вернуть ответ 405. Появился в HTTP/1.0.
502 Bad Gateway — сервер, выступая в роли шлюза или прокси-сервера, получил недействительное ответное сообщение от вышестоящего сервера. Появился в HTTP/1.0.
503 Service Unavailable — сервер временно не имеет возможности обрабатывать запросы по техническим причинам (обслуживание, перегрузка и прочее). В поле Retry-After заголовка сервер может указать время, через которое клиенту рекомендуется повторить запрос. Хотя во время перегрузки очевидным кажется сразу разрывать соединение, эффективней может оказаться установка большого значения поля Retry-After для уменьшения частоты избыточных запросов. Появился в HTTP/1.0.
504 Gateway Timeout — сервер в роли шлюза или прокси-сервера не дождался ответа от вышестоящего сервера для завершения текущего запроса. Появился в HTTP/1.1.
505 HTTP Version Not Supported — сервер не поддерживает или отказывается поддерживать указанную в запросе версию протокола HTTP. Появился в HTTP/1.1.
506 Variant Also Negotiates — в результате ошибочной конфигурации выбранный вариант указывает сам на себя, из-за чего процесс связывания прерывается. Экспериментальное. Введено в RFC 2295 для дополнения протокола HTTP технологией Transparent Content Negotiation.
507 Insufficient Storage — не хватает места для выполнения текущего запроса. Проблема может быть временной. Введено в WebDAV.
508 Loop Detected — операция отменена, т.к. сервер обнаружил бесконечный цикл при обработке запроса без ограничения глубины. Введено в WebDAV.
508 Resource Limit is Reached — вариант ошибки 508 в Apache HTTP Server, возникающий при исчерпании лимитов хостинга.
509 Bandwidth Limit Exceeded — используется при превышении веб-площадкой отведённого ей ограничения на потребление трафика. В данном случае владельцу площадки следует обратиться к своему хостинг-провайдеру. В настоящий момент данный код не описан ни в одном RFC и используется только модулем «bw/limited», входящим в панель управления хостингом cPanel, где и был введён.
510 Not Extended — на сервере отсутствует расширение, которое желает использовать клиент. Сервер может дополнительно передать информацию о доступных ему расширениях. Введено в RFC 2774 для дополнения протокола HTTP поддержкой расширений.
511 Network Authentication Required — этот ответ посылается не сервером, которому был предназначен запрос, а сервером-посредником — например, сервером провайдера — в случае, если клиент должен сначала авторизоваться в сети, например, ввести пароль для платной точки доступа к Интернету. Предполагается, что в теле ответа будет возвращена Web-форма авторизации или перенаправление на неё. Введено в черновике стандарта RFC 6585.
520 Unknown Error, возникает когда сервер CDN не смог обработать ошибку веб-сервера; нестандартный код CloudFlare.
521 Web Server Is Down, возникает когда подключения CDN отклоняются веб-сервером; нестандартный код CloudFlare.
522 Connection Timed Out, возникает когда CDN не удалось подключиться к веб-серверу; нестандартный код CloudFlare.
523 Origin Is Unreachable, возникает когда веб-сервер недостижим; нестандартный код CloudFlare.
524 A Timeout Occurred, возникает при истечении тайм-аута подключения между сервером CDN и веб-сервером; нестандартный код CloudFlare.
525 SSL Handshake Failed, возникает при ошибке рукопожатия SSL между сервером CDN и веб-сервером; нестандартный код CloudFlare.
526 Invalid SSL Certificate, возникает когда не удаётся подтвердить сертификат шифрования веб-сервера; нестандартный код CloudFlare.

5) Что такое ядро браузера 
Браузер = оболочка + ядро
Среди них относительно больше типов оболочек и меньше ядер. Оболочка относится к оболочке браузера: например, меню, панели инструментов и т. Д. Он в основном предназначен для работы с пользовательским интерфейсом, настройки параметров и так далее. Он вызывает ядро ​​для реализации различных функций. Ядро - это ядро ​​браузера. Ядро - это программа или модуль, который отображает контент на основе языка разметки.

Что такое ядро ​​браузера
Ядро браузера можно разделить на две части: движок рендеринга (инженер макета или движок рендеринга) и движок JS. Он отвечает за получение содержимого веб-страницы (HTML, XML, изображения и т. Д.), Организацию информации (например, добавление CSS и т. Д.) И расчет режима отображения веб-страницы, а затем вывод ее на монитор или принтер. Разница в ядре браузера будет по-разному интерпретировать синтаксис веб-страницы, поэтому эффект рендеринга будет другим. Все веб-браузеры, почтовые клиенты и другие приложения, которым необходимо редактировать и отображать сетевой контент, требуют ядра. (См. Википедия). Движок JS анализирует язык Javascript и выполняет язык Javascript для достижения динамических эффектов веб-страницы. Сначала не было четкого различия между движком рендеринга и движком JS, а позже движок JS становился все более независимым, и ядро ​​имело тенденцию ссылаться только на движок рендеринга. Механизм рендеринга определяет, как браузер отображает содержимое веб-страницы и информацию о формате страницы. Разные ядра браузеров по-разному интерпретируют синтаксис записи веб-страниц, поэтому эффект рендеринга (отображения) одной и той же веб-страницы в браузерах разных ядер также может быть различным. Именно поэтому авторам веб-страниц необходимо тестировать веб-страницы в браузерах разных ядер. Покажите причину эффекта. Движок JS отвечает за интерпретацию, компиляцию и выполнение JavaScript, чтобы заставить веб-страницу достигать некоторых динамических эффектов. Но обычные ядра браузера можно разделить на эти пять типов: Trident, Gecko, Presto, Webkit, Blink.

6) Какие браузеры какие ядра используют

Классификация ядра

Trident (ядро IE): Эта программа ядра была впервые принята в IE4 в 1997 году. Она была изменена Microsoft на основе кода Mosaic и продолжала использовать IE11. Она также обычно называется «ядром IE». Trident на самом деле является открытым ядром, и его интерфейсное ядро ​​достаточно развито, поэтому есть много браузеров (оболочек), которые используют IE вместо ядра IE к
Из-за «монополии» самого IE (хотя IE не является монополией по названию, но на самом деле, особенно с Windows 95 до первых дней XP, IE действительно использовал Dongfeng Windows находится в «монопольном» положении и долгое время доминировало над ядром Trident. Microsoft долгое время не обновляла ядро ​​Trident. Это привело к двум последствиям, одно из которых состоит в том, что ядро ​​Trident почти не касалось стандарта W3C ( 2005 г.) Во-вторых, большое количество ошибок и других проблем безопасности в ядре Trident не было решено вовремя, и затем некоторые разработчики и некоторые ученые, которые привержены открытому исходному коду, открывают свое мнение, что Internet Explorer небезопасен, и многие пользователи обратились к нему. В это время появились другие браузеры, Firefox и Opera. Значительное увеличение доли рынка браузеров с ядром без Trident также заставило многих веб-разработчиков обратить внимание на веб-стандарты и эффекты просмотра браузеров без IE. к
Дополнение: начиная с версии 11 IE изначально поддерживает технологию WebGL. Механизм JavaScript IE8 - Jscript, и IE9 начал использовать Chakra. Две версии очень разные. Chakra превосходна с точки зрения скорости и стандартизации. к
Общие браузеры с ядром Trident: [1] IE6, IE7, IE8 (Trident 4.0), IE9 (Trident 5.0), IE10 (Trident 6.0); [1] 360 браузер безопасности (1.0-5.0 - Trident, 6.0 - Trident + Webkit, 7.0 - Trident + Blink)Гепард Ультра Лайт Браузер360-скоростной браузер (Trident + Webkit до 7.5, Trident + Blink для 7.5)Cheetah Safe Browser(Версия 1.0-4.2 - Trident + Webkit, 4.3 и более поздние версии - Trident + Blink) Сверхлегкий браузер Cheetah, браузер Maxthon (Maxthon 1.x и 2.x - ядро ​​IE, 3.x - двухъядерный IE и Webkit) , Браузер Baidu (ранняя версия), браузер Window of the World [2] (изначально ядро ​​IE, ядро ​​Chrome + IE, выпущенное в 2013 году), браузер 2345, Tencent TT, браузер Taobao, браузер сбора и чтения, Sogou Express Браузер (Trident для 1.x, Trident + Webkit для 2.0 и более поздних версий), браузер Ayun (ранняя версия),Rising Security Browser, Тонкий браузер, GreenBrowser, браузер Aifan (версия до 12), браузер 115, браузер 155, флэш-браузер, браузер оксида углерода, браузер конфет, браузер Rainbow, браузер Ruiying, Храбрый без границ Браузер, браузер 114, браузер Ant, браузер Feiteng, браузер Suda, браузер Zorro, браузер Dolphin (iPhone / iPad / Android), браузер UC (ядро Blink + ядро ​​Trident) и т. Д. к
Новая версия некоторых браузеров является «двухъядерной» или даже «многоядерной», один из которых - Trident, а затем добавляется еще один. Отечественные производители обычно называют другие ядра «высокоскоростным режимом просмотра», тогда как Trident является «совместимым режимом просмотра», и пользователи могут переключаться между ними.

Gecko (ядро Firefox): Netscape 6 начал внедрять ядро, а позже Mozilla FireFox (браузер Firefox) также принял это ядро. Отличительной чертой Gecko является то, что код полностью открыт, поэтому его можно разрабатывать в высокой степени. Программисты по всему миру Вы можете написать код для него и добавить функциональность. Поскольку это ядро ​​с открытым исходным кодом, многие его одобряют, и для ядра Gecko существует множество браузеров, что является важной причиной того, что ядро ​​Gecko является молодым, но его доля на рынке может быстро возрасти. к
На самом деле происхождение движка Gecko не связано с IE. Ранее я говорил, что IE не использует стандарты W3C, что вызвало недовольство у некоторых разработчиков в Microsoft; они прекратили обновление Некоторые сотрудники Netscape вместе основали Mozilla, переписали ядро ​​на основе ядра Mosaic и разработали Gecko. Но на самом деле браузер ядра Gecko по-прежнему Firefox (Firefox) с большинством пользователей, поэтому его иногда называют ядром Firefox. Кроме того, Gecko также является кроссплатформенным ядром, которое можно использовать в Windows, BSD, Linux и Mac OS X. к
Дополнение: движком JavaScript является SpiderMonkey. 
Общие браузеры с ядром Gecko: [1] Mozilla Firefox, Mozilla SeaMonkey, waterfox (64-разрядная версия Firefox с открытым исходным кодом), Iceweasel, Epiphany (ранняя версия), Flock (ранняя версия), K-Meleon

Presto (pre-Opera kernel) (устарело): ядро, используемое в Opera 12.17 и более ранних версиях, прекратило разработку и теперь устарело. Ядро впервые использовалось в Opera7 в 2003 году. Особенностью этого движка является скорость рендеринга. Оптимизация достигла предела, но цена за счет веб-совместимости. к
На самом деле это динамическое ядро. Самым большим отличием от предыдущих ядер является обработка скриптов. У Presto есть естественное преимущество. Вся или часть страницы может реагировать на события скрипта. Время от времени пересматривается. Кроме того, ядро ​​имеет самую высокую скорость при выполнении Javascrīpt. Согласно тестам в тех же условиях, время, необходимое для того, чтобы ядро ​​Presto выполнило тот же Javascrīpt, составляет всего около 1/3 от ядер Trident и Gecko (ядро Trident - самое медленное, но два Между ними нет большой разницы.) Один из модификаторов этой статьи считает, что приведенная выше информация о тестировании слишком старая и неполная, потому что небольшой тест, который он провел, показывает, что часть Presto является быстрой, а часть - медленной, а ядра в целом эквивалентны. В этом тесте, поскольку аппаратные условия компьютера Apple отличались от обычных компьютеров, ядро ​​WebCore не тестировалось. Жаль, что Presto - это коммерческий движок. Помимо Opera единственными, которые используют Presto, являются NDSBrowser, Wii Internet Channle, веб-браузер Nokia 770 и т. Д. Это в значительной степени ограничивает разработку Presto. 
Opera перешла на ядро ​​Google Chrome Blink.

Webkit (ядро Safari, прототип ядра Chrome, открытый исходный код): это собственное ядро ​​Apple и ядро, используемое браузером Safari от Apple. Движок Webkit включает в себя механизм верстки WebCore и механизм синтаксического анализа JavaScriptCore, оба производные от KDE KHTML и KJS, все они являются свободным программным обеспечением, лицензированным по соглашению GPL, и поддерживают разработку систем BSD. Так что Webkit - это также бесплатное программное обеспечение и открытый исходный код. С точки зрения безопасности, он не ограничен IE и Firefox, поэтому браузер Safari все еще очень безопасен в Китае. к
ограничивается тем, что Mac OS X не используется широко, а браузер Safari когда-то был эксклюзивным браузером Mac OS X. Можно сказать, что само это ядро ​​имеет небольшую рыночную область применения, но, похоже, оно основано на новейшем браузере Опрос показывает, что рынок браузеров даже превзошел Presto. Конечно, это связано с растущей популярностью Apple после перехода на архитектуру x86, а также с тем, что Safari 3 наконец-то запустил версию для Windows. Есть также популярные браузеры, такие как OmniWeb и Shiira под Mac. к
В быстродействующем режиме высокоскоростного браузера Sogou также используется Webkit в качестве ядра (с точки зрения понимания сценариев Chrome использует собственный разработанный движок V8). Ядро WebKit также широко используется в мобильных телефонах, например, мобильный телефон Google Gphone, iPhone Apple, браузер Nokia Series 60 и другие ядра ядра браузера - все основано на WebKit. к
Основные браузеры WebKit: браузер Maxthon 3, [1] Apple Safari (Win / Mac / iPhone / iPad), мобильный браузер Symbian, браузер Android по умолчанию,\\

Внедрение продукции
Blink - это механизм верстки браузера, разработанный Google и Opera Software. Google планирует использовать этот механизм рендеринга в рамках проекта Chromium, и анонсировал эту новость в апреле 2013 года. , Этот движок рендеринга является ветвью компонента WebCore движка с открытым исходным кодом WebKit и используется в браузерах Chrome (28 и более поздние версии), Opera (15 и более поздние версии) и Яндекса.

подводить итоги
IE (до 9) = Trident + Jscript
IE (после 9) = трезубец + чакра
360=Trident+Blink 
Sogou = Trident + WebKit
Firefox=Gecko+JagerMonkey 
Safari=webkit=webcore+jscore 
Chrome=Blink+v8 
Opera=Blink+v8

7) Что такое API

API (МФА [ˌeɪ.piˈaɪ]; аббр. от англ. Application Programming Interface — «программный интерфейс приложения») — описание способов (набор классов, процедур, функций, структур или констант), которыми одна компьютерная программа может взаимодействовать с другой программой. Обычно входит в описание какого-либо интернет-протокола (например, SCIM), программного каркаса (фреймворка) или стандарта вызовов функций операционной системы. Часто реализуется отдельной программной библиотекой или сервисом операционной системы. Используется программистами при написании всевозможных приложений. Проще говоря, это набор компонентов, с помощью которых компьютерная программа (бот или же сайт) может взаимодействовать с другой программой (API).

Назначение
API (интерфейс прикладного программирования) упрощает процесс программирования при создании приложений, абстрагируя базовую реализацию и предоставляя только объекты или действия, необходимые разработчику. Если графический интерфейс для почтового клиента может предоставить пользователю кнопку, которая выполнит все шаги для выборки и выделения новых писем, то API для ввода/вывода файлов может дать разработчику функцию, которая копирует файл из одного места в другое, не требуя от разработчика понимания операций файловой системы, происходящих за кулисами.[5]

API как средство интеграции приложений
Если программу (модуль, библиотеку) рассматривать как чёрный ящик, то API — это набор «ручек», которые доступны пользователю данного ящика и которые он может вертеть и дёргать.

Программные компоненты взаимодействуют друг с другом посредством API. При этом обычно компоненты образуют иерархию — высокоуровневые компоненты используют API низкоуровневых компонентов, а те, в свою очередь, используют API ещё более низкоуровневых компонентов.

По такому принципу построены протоколы передачи данных по Интернету. Стандартный стек протоколов (сетевая модель OSI) содержит 7 уровней (от физического уровня передачи бит до уровня протоколов приложений, подобных протоколам HTTP и IMAP). Каждый уровень пользуется функциональностью предыдущего («нижележащего») уровня передачи данных и, в свою очередь, предоставляет нужную функциональность следующему («вышележащему») уровню.

Понятие протокола близко по смыслу к понятию API. И то, и другое является абстракцией функциональности, только в первом случае речь идёт о передаче данных, а во втором — о взаимодействии приложений.

API библиотеки функций и классов включает в себя описание сигнатур и семантики функций.

Сигнатура функции
Сигнатура функции — часть общего объявления функции, позволяющая средствам трансляции идентифицировать функцию среди других. В различных языках программирования существуют разные представления о сигнатуре функции, что также тесно связано с возможностями перегрузки функций в этих языках.

Иногда различают сигнатуру вызова и сигнатуру реализации функции. Сигнатура вызова обычно составляется по синтаксической конструкции вызова функции с учётом сигнатуры области видимости данной функции, имени функции, последовательности фактических типов аргументов в вызове и типе результата. В сигнатуре реализации обычно участвуют некоторые элементы из синтаксической конструкции объявления функции: спецификатор области видимости функции, её имя и последовательность формальных типов аргументов.

Например, в языке программирования C++ простая функция однозначно опознаётся компилятором по своему имени и последовательности типов своих аргументов, что составляет сигнатуру функции в этом языке. Если функция является методом некоторого класса, то в сигнатуре будет участвовать и имя класса.

В языке программирования Java сигнатуру метода составляют его имя и последовательность типов параметров; тип возвращаемого значения в сигнатуре не участвует.[6]

Семантика функции
Семантика функции — это описание того, что данная функция делает. Семантика функции включает в себя описание того, что является результатом вычисления функции, как и от чего этот результат зависит. Обычно результат выполнения зависит только от значений аргументов функции, но в некоторых модулях есть понятие состояния. Тогда результат функции может зависеть от этого состояния, и, кроме того, результатом может стать изменение состояния. Логика этих зависимостей и изменений относится к семантике функции. Полным описанием семантики функций является исполняемый код функции или математическое определение функции.

API операционных систем. Проблемы, связанные с многообразием API
Практически все операционные системы (UNIX, Windows, OS X, Linux и т. д.) имеют API, с помощью которого программисты могут создавать приложения для этой операционной системы. Главный API операционных систем — это множество системных вызовов.

В индустрии программного обеспечения общие стандартные API для стандартной функциональности играют важную роль, так как они гарантируют, что все программы, использующие общий API, будут работать одинаково хорошо или, по крайней мере, типичным привычным образом. В случае API графических интерфейсов это означает, что программы будут иметь похожий пользовательский интерфейс, что облегчает процесс освоения новых программных продуктов.

С другой стороны, различия в API различных операционных систем существенно затрудняют перенос приложений между платформами. Существуют различные методы обхода этой сложности — написание «промежуточных» API (API графических интерфейсов wxWidgets, GTK и т. п.), написание библиотек, которые отображают системные вызовы одной ОС в системные вызовы другой ОС (такие среды исполнения, как Wine, cygwin и т. п.), введение стандартов кодирования в языках программирования (например, стандартная библиотека языка C), написание интерпретируемых языков, реализуемых на разных платформах (sh, Python, Perl, PHP, Tcl, Javascript, Ruby и т. д.).

Также в распоряжении программиста часто находится несколько различных API, позволяющих добиться одного и того же результата. При этом каждый API обычно реализован с использованием API программных компонент более низкого уровня абстракции.

Например: для того, чтобы увидеть в браузере строчку «Hello, world!», достаточно лишь создать HTML-документ с минимальным заголовком и простейшим телом, содержащим данную строку. Когда браузер откроет этот документ, программа-браузер передаст имя файла (или уже открытый дескриптор файла) библиотеке, обрабатывающей HTML-документы, та, в свою очередь, при помощи API операционной системы прочитает этот файл и разберётся в его устройстве, затем последовательно вызовет через API библиотеки стандартных графических примитивов операции типа «очистить окошко», «написать „Hello, world!“ выбранным шрифтом». Во время выполнения этих операций библиотека графических примитивов обратится к библиотеке оконного интерфейса с соответствующими запросами, уже эта библиотека обратится к API операционной системы, чтобы записать данные в буфер видеокарты.

При этом практически на каждом из уровней реально существует несколько возможных альтернативных API. Например: мы могли бы писать исходный документ не на HTML, а на LaTeX, для отображения могли бы использовать любой браузер. К тому же различные браузеры используют различные HTML-библиотеки, и, кроме того, всё это может быть собрано с использованием различных библиотек примитивов и на различных операционных системах.

Основными сложностями существующих многоуровневых систем API, таким образом, являются:

Сложность портирования программного кода с одной системы API на другую (например, при смене ОС);
Потеря функциональности при переходе с более низкого уровня на более высокий. Грубо говоря, каждый «слой» API создаётся для облегчения выполнения некоторого стандартного набора операций. Но при этом реально затрудняется, либо становится принципиально невозможным выполнение некоторых других операций, которые предоставляет более низкий уровень API.

Наиболее известные API
Операционных систем
Cocoa
Linux Kernel API[en]
OS/2 API
Windows API
Графических интерфейсов
DirectDraw/Direct3D (часть DirectX)
SFML
OpenVG
SDL
Vulkan
Mantle
Звуковых интерфейсов
DirectMusic/DirectSound (часть DirectX)
OpenAL
Аутентификационных систем
BioAPI
PAM
Web API
Используется в веб-разработке — содержит, как правило, определённый набор HTTP-запросов, а также определение структуры HTTP-ответов, для выражения которых используют XML− или JSON−формат.

Web API является практически синонимом для веб-службы, хотя в последнее время за счёт тенденции Web 2.0 осуществлён переход от SOAP к REST типу коммуникации. Веб-интерфейсы, обеспечивающие сочетание нескольких сервисов в новых приложениях, известны как гибридные.
Примеры: MediaWiki API

8. Что такое ендпоинты

Эндпоинт (в переводе с англ. — конечная точка) представляет собой некий шлюз, который соединяет серверные процессы приложения с внешним интерфейсом. Простыми словами, это адрес, на который отправляются сообщения.
Чтобы понять, что такое эндпоинты, важно упомянуть работу API. API — аббревиатура от application programming interface, что переводится как программный интерфейс приложения. Приложения используют API для взаимодействия со сторонними приложениями и своими пользователями.
Чтобы связаться с API, нужно отправить ему запрос. Для корректной обработки запроса клиент должен предоставить универсальный указатель ресурса (URL), метод (HTTP method), и в зависимости от метода добавить заголовки (headers), тело (body), параметры запроса. Заголовки предоставляют метаданные о запросе, а тело содержит данные, например, поля для новой строки в базе данных.
API обработает запрос и отправит ответ, полученный от сервера. Ответ будет содержать код состояния, который является частью ответного сообщения HTTP, информирующего клиента о результате запроса. Например, код 200 используется, если операция завершилась успешно, 500 — если произошла внутренняя ошибка сервера.

Эндпоинты работают вместе с методами API. Это определенные URL-адреса, которые приложение использует для связи со сторонними службами и своими пользователями. URL — это роут, который может обрабатывать разные методы запроса. Каждый тип запроса — это отдельный эндпоинт. Существует пять основных типов:

GET — получает информацию с сервера, не требует тела запроса;
POST — создает в базе новый объект, требует тело запроса с полями этого объекта;
PUT — полностью обновляет конкретный объект в базе данных;
PATCH — аналогично PUT, обновляет определенный объект в базе данных, но обновляет только те поля, которые указаны в теле запроса;
DELETE — удаляет объект из базы данных.

При формировании конкретного запроса к нему могут добавляться разные параметры. Комбинация этих параметров и URL представляет URI — Uniform Resource Identifier (унифицированный идентификатор ресурса), который указывает, где и как найти ресурс.
Все эндпоинты группируются. Внутри каждой группы вы найдете список соответствующих эндпоинтов, их типы запросов, URL-адреса и бизнес-процессы, к которым они подключены. Все эндпоинты можно удалять и редактировать.
Эндпоинты — неотъемлемая часть в работе API, который в свою очередь необходим для расширения проектов и удобной интеграции сервисов и приложений. No-code платформа AppMaster.io позволяет легко работать с эндпоинтами, создавать и настраивать их. Вы всегда можете зарегистрироваться на платформе и проверить весь функционал.

9) URL (URI, URL, URN)

Унифицированный указатель ресурса (от англ. Uniform Resource Locator, сокр.  URL [ˌjuː ɑːr ˈel]) — система унифицированных адресов электронных ресурсов, или единообразный определитель местонахождения ресурса (файла)[1].
Используется как стандарт записи ссылок на объекты в Интернете (Гипертекстовые ссылки во «всемирной паутине» www).
Для обозначения электронного адреса используют аббревиатуру «URL» по ГОСТ Р 7.0.5-2008.

История
URL был изобретён Тимом Бернерсом-Ли в 1990 году в стенах Европейского совета по ядерным исследованиям (фр. Conseil Européen pour la Recherche Nucléaire, CERN) в Женеве, Швейцария. URL стал фундаментальной инновацией в Интернете. Изначально URL предназначался для обозначения мест расположения ресурсов (чаще всего файлов) во Всемирной паутине. Сейчас URL применяется для обозначения адресов почти всех ресурсов Интернета. Стандарт URL закреплён в документе RFC 3986. Сейчас URL позиционируется как часть более общей системы идентификации ресурсов URI, сам термин URL постепенно уступает место более широкому термину URI. Стандарт URL регулируется организацией IETF и её подразделениями. В 2009 году Тим Бернерс-Ли высказал мнение об избыточности двойного слеша // в начале URL, после указания сетевого протокола.

Структура URL
URL был разработан как система для максимально естественного указания на местонахождения ресурсов в сети. Локатор должен был быть легко расширяемым и использовать лишь ограниченный набор ASCII‐символов (к примеру, в URL никогда не применяется пробел). В связи с этим возникла следующая традиционная форма записи URL:

<схема>:[//[<логин>[:<пароль>]@]<хост>[:<порт>]][/<URL‐путь>][?<параметры>][#<якорь>]

В этой записи:
- схема: схема обращения к ресурсу; в большинстве случаев имеется в виду сетевой протокол
- логин: имя пользователя, используемое для доступа к ресурсу
- пароль: пароль указанного пользователя
- хост: полностью прописанное доменное имя хоста в системе DNS или IP-адрес хоста в форме четырёх групп десятичных чисел, разделённых точками; числа — целые в интервале от 0 до 255.
- порт: порт хоста для подключения
- URL-путь: уточняющая информация о месте нахождения ресурса; зависит от протокола.
- параметры: строка запроса с передаваемыми на сервер (методом GET) параметрами. Начинается с символа ?, разделитель параметров — знак &. Пример: ?параметр_1=значение_1&параметр_2=значение_2&параметр3=значение_3
- якорь: идентификатор «якоря»  (англ.)рус. с предшествующим символом #. Якорем может быть указан заголовок внутри документа или атрибут id  (англ.)рус. элемента. По такой ссылке браузер откроет страницу и переместит окно к указанному элементу. Например, ссылка на этот раздел статьи: https://ru.wikipedia.org/wiki/URL#Структура_URL.

Схемы (протоколы) URL
ftp — протокол передачи файлов FTP
http — протокол передачи гипертекста HTTP
rtmp — проприетарный протокол потоковой передачи данных Real Time Messaging Protocol, в основном используется для передачи потокового видео и аудио с веб-камер через Интернет.
rtsp — потоковый протокол реального времени.
https — специальная реализация протокола HTTP, использующая шифрование (как правило, SSL или TLS)
gopher — протокол Gopher
mailto — адрес электронной почты
news — новости Usenet
nntp — новости Usenet через протокол NNTP
irc — протокол IRC
smb — протокол SMB/CIFS
prospero — служба каталогов Prospero Directory Service
telnet — ссылка на интерактивную сессию Telnet
wais — база данных системы WAIS
xmpp — протокол XMPP (часть Jabber)
file — имя локального файла
data — непосредственные данные (Data: URL)
tel — звонок по указанному телефону

Экзотические схемы URL:
afs — глобальное имя файла в файловой системе Andrew File System
cid — идентификатор содержимого для частей MIME
mid — идентификатор сообщений для электронной почты
mailserver — доступ к данным с почтовых серверов
nfs — имя файла в сетевой файловой системе NFS
tn3270 — эмуляция интерактивной сессии Telnet 3270
z39.50 — доступ к службам ANSI Z39.50
skype — протокол Skype
smsto — открытие редактора SMS в некоторых мобильных телефонах
ed2k — файлообменная сеть eDonkey, построенная по принципу P2P
market — Android-маркет
steam — протокол Steam
bitcoin — криптовалюта Биткойн
ob — OpenBazaar
tg — Telegram

Схемы URL в браузерах:
view-source — просмотр исходного кода указанной веб-страницы в различных браузерах.
В разных браузерах используются разные ключевые слова для доступа к служебным и сервисным страницам:
chrome в браузере Google Chrome и других браузерах на движке Chromium[4];

about в Firefox и других браузерах на движке Gecko;
opera в Opera;
browser в Яндекс.Браузер.

Кодирование URL
Стандарт URL использует набор символов US-ASCII. Это имеет серьёзный недостаток, поскольку разрешается использовать лишь латинские буквы, цифры и несколько знаков пунктуации. Все другие символы необходимо перекодировать. Например, перекодироваться должны буквы кириллицы, буквы с диакритическими знаками, лигатуры, иероглифы. Перекодирующая кодировка описана в стандарте RFC 3986 и называется URL-encoding, URLencoded или percent‐encoding.

Пример кодирования можно видеть в русскоязычной Википедии, использующей в URL русский язык. Например, строка вида:

https://ru.wikipedia.org/wiki/Википедия
кодируется как:

https://ru.wikipedia.org/wiki/%D0%92%D0%B8%D0%BA%D0%B8%D0%BF%D0%B5%D0%B4%D0%B8%D1%8F

Реализация
Преобразование происходит в два этапа: сначала каждый символ кириллицы кодируется в UTF-8 в последовательность из двух байтов, а затем каждый байт этой последовательности записывается в шестнадцатеричном представлении с предшествующим знаком процента (%):

В → D0 и 92 → %D0%92
и → D0 и B8 → %D0%B8
к → D0 и BA → %D0%BA
и → D0 и B8 → %D0%B8, и т. д

Зарезервированные символы[5]
!	*	'	(	)	;	:	@	&	=	+	$	,	/	?	#	[	]
Не зарезервированные символы[5]
A	B	C	D	E	F	G	H	I	J	K	L	M	N	O	P	Q	R	S	T	U	V	W	X	Y	Z
a	b	c	d	e	f	g	h	i	j	k	l	m	n	o	p	q	r	s	t	u	v	w	x	y	z
0	1	2	3	4	5	6	7	8	9	-	_	.	~	
Все другие символы в URI кодируются.

Зарезервированные символы кодируются в таком соответствии:

!	"	#[6]	$	%	&[6]	'	*	+	,[6]	:[6]	;[6]	<	=[6]	>	?[6]	[	]	^	`	{	|	}	<пробел>
%21	%22	%23	%24	%25	%26	%27	%2A	%2B	%2C	%3A	%3B	%3C	%3D	%3E	%3F	%5B	%5D	%5E	%60	%7B	%7C	%7D	%20[7]
Кодирование параметров в Internet Explorer и старом Firefox происходит несколько иначе[8].

В некоторых случаях URL формируется с использованием кодирования Base58[9].

Стандарт IRI
Основная статья: Internationalized Resource Identifier
Поскольку такому преобразованию подвергаются буквы всех алфавитов, кроме базовой латиницы, то URL со словами подавляющего большинства языков может стать нечитаемым для человека.

Это всё входит в противоречие с принципом интернационализма, провозглашаемого всеми ведущими организациями Интернета, включая W3C и ISOC. Эту проблему призван решить стандарт IRI (англ. Internationalized Resource Identifier) — международных идентификаторов ресурсов, в которых можно было бы без проблем использовать символы Юникода, и которые поэтому не ущемляли бы права других языков. Хотя заранее сложно сказать, смогут ли когда‐либо идентификаторы IRI заменить столь широко используемые URL (и URI в целом).

Ограничение длины
Формально, длина URL не ограничена, но браузеры имеют ограничения по длине URL. Не рекомендуется использовать URL длиной более 2048 символов, так как Microsoft Internet Explorer имеет именно такое ограничение[10].

Инициатива PURL
Ещё один кардинальный недостаток URL состоит в отсутствии гибкости. Ресурсы во Всемирной паутине и Интернете перемещаются, а ссылки в виде URL остаются, указывая на уже отсутствующие ресурсы. Это особенно болезненно для электронных библиотек, каталогов и энциклопедий. Для решения этой проблемы были предложены постоянные локаторы PURL (англ. Persistent Uniform Resource Locator). В сущности это те же URL, но они указывают не на конкретное место расположения ресурса, а на запись в базе данных PURL, где, в свою очередь, записан уже конкретный URL‐адрес ресурса. При обращении к PURL сервер находит нужную запись в этой базе данных и перенаправляет запрос уже на конкретное местоположение ресурса. Если адрес ресурса меняется, то нет нужды исправлять все бесчисленные ссылки на него — достаточно лишь изменить запись в БД. В настоящий момент эта идея не стандартизирована и не имеет широкого распространения.


10) Идемпотентные HTTP методы

Идемпотентный метод
Метод HTTP является идемпотентным, если повторный идентичный запрос, сделанный один или несколько раз подряд, имеет один и тот же эффект, не изменяющий состояние сервера. Другими словами, идемпотентный метод не должен иметь никаких побочных эффектов (side-effects), кроме сбора статистики или подобных операций. Корректно реализованные методы GET, HEAD, PUT и DELETE идемпотентны, но не метод POST. Также все безопасные методы являются идемпотентными.
Для идемпотентности нужно рассматривать только изменение фактического внутреннего состояния сервера, а возвращаемые запросами коды статуса могут отличаться: первый вызов DELETE вернёт код 200, в то время как последующие вызовы вернут код 404. Из идемпотентности DELETE неявно следует, что разработчики не должны использовать метод DELETE при реализации RESTful API с функциональностью удалить последнюю запись.
Обратите внимание, что идемпотентность метода не гарантируется сервером, и некоторые приложения могут нарушать ограничение идемпотентности.
Из спецификации HTTP:

Метода	        Безопасный	 Идемпотентный	        Ссылка
CONNEСТ              нет	             нет	      Section 4.3.6
DELETE	              нет	              да	      Section 4.3.5
GET	               да	              да	      Section 4.3.1
HEAD	               да	              да	      Section 4.3.2
OPTIONS	               да	              да	      Section 4.3.7
POST	               нет	             нет	       Section 4.3.3
PUT	               нет	              да	       Section 4.3.4
TRACE	                да	               да	        Section 4.3.8

Согласно стандарту HTTP, запросы типа GET считаются идемпотентными.

11) Безопасные HTTP методы

Метод HTTP является безопасным, если он не меняет состояние сервера. Другими словами, безопасный метод проводит операции "только чтение" (read-only). Несколько следующих методов HTTP безопасные: GET, HEAD или OPTIONS. Все безопасные методы являются также идемпотентными, как и некоторые другие, но при этом небезопасные, такие как PUT или DELETE.

Даже если безопасные методы являются по существу "только для чтения", сервер всё равно может сменить своё состояние: например, он может сохранять статистику. Что существенно, так то, когда клиент вызывает безопасный метод, то он не запрашивает никаких изменений на сервере, и поэтому не создаёт дополнительную нагрузку на сервер. Браузеры могут вызывать безопасные методы, не опасаясь причинить вред серверу: это позволяет им выполнять некоторые действия, например, предварительная загрузка без риска. Поисковые роботы также полагаются на вызовы безопасных методов.

Безопасные методы не обязательно должны обрабатывать только статичные файлы; сервер может генерировать ответ "на-лету", пока скрипт, генерирующий ответ, гарантирует безопасность: он не должен вызывать внешних эффектов, таких как формирование заказов, отправка писем и др..

Правильная реализация безопасного метода - это ответственность серверного приложения, потому что сам веб-сервер, будь то Apache, nginx, IIS это соблюсти не сможет. В частности, приложение не должно разрешать изменение состояния сервера запросами GET.

Вызов безопасного метода, не меняющего состояния сервера:
GET /pageX.html HTTP/1.1
Вызов небезопасного метода, который может поменять состояние сервера:
POST /pageX.html HTTP/1.1 
Вызов идемпотентного, но небезопасного метода:
DELETE /idX/delete HTTP/1.1

12) Иденфикация, Аутентификация, Авторизация

Мы постоянно идентифицируемся, аутентифицируемся и авторизуемся в разнообразных системах. И все же многие путают значение этих слов и часто употребляют термин «идентификация» или «авторизация», хотя на самом деле речь идет об аутентификации. Ничего страшного в этом нет, часто обе стороны диалога понимают, что в действительности имеется в виду. Но всегда лучше знать и понимать слова, которые употребляем.
Определения
Что же значат все эти термины, и чем соответствующие процессы отличаются друг от друга?

Идентификация – процедура, в результате выполнения которой для субъекта выявляется его уникальный признак, однозначно определяющий его в информационной системе.
Аутентификация – процедура проверки подлинности, например, проверка подлинности пользователя путем сравнения введенного им пароля с паролем, сохраненным в базе данных.
Авторизация – предоставление определенному лицу прав на выполнение определенных действий.

Примеры:
Пользователь хочет войти в свой аккаунт Google (Google подходит лучше всего, потому что там процедура входа явным образом разбита на несколько простейших этапов). Вот что при этом происходит:
Сачала система запрашивает логин, пользователь его указывает, система распознает его как существующий — это идентификация.
После этого Google просит ввести пароль, пользователь его вводит, и система соглашается, что пользователь действительно настоящий, ведь пароль совпал, — это аутентификация.
Возможно, Google дополнительно спросит еще и одноразовый код из SMS или приложения. Если пользователь и его правильно введет, то система окончательно согласится с тем, что он настоящий владелец аккаунта, — это двухфакторная аутентификация.
После этого система предоставит пользователю право читать письма в его почтовом ящике и все остальное — это авторизация.
Аутентификация без предварительной идентификации лишена смысла – пока система не поймет, подлинность чего же надо проверять, совершенно бессмысленно начинать проверку. Для начала надо представиться.

Идентификация без аутентификации не работает. Потому что мало ли кто ввел существующий в системе логин! Системе обязательно надо удостовериться, что этот кто-то знает еще и пароль. Но пароль могли подсмотреть или подобрать, поэтому лучше подстраховаться и спросить что-то дополнительное, известное только данному пользователю: например, одноразовый код для подтверждения входа.

А вот авторизация без идентификации и аутентификации очень даже возможна. Например, в Google Документах можно публиковать документы так, чтобы они были доступны всем. В этом случае вы как владелец файла увидите сверху надпись, гласящую, что его читает неопознанный субъект. Несмотря на это, система его все же авторизовала – то есть выдала право прочитать этот документ.

Но если вы открыли этот документ для чтения только определенным пользователям, то им в таком случае сперва пришлось бы идентифицироваться (ввести свой логин), потом аутентифицироваться (ввести пароль и одноразовый код) и только потом получить право на чтение документа – авторизоваться.
Если же речь идет о содержимом вашего почтового ящика, то Google никогда и ни за что не авторизует неопознанного субъекта на чтение вашей переписки.

Аутентификация – пожалуй, самый важный из этих процессов с точки зрения безопасности вашего аккаунта. Если вы ленитесь и используете для аутентификации только простенький пароль, то какой-нибудь злоумышленник может ваш аккаунт угнать. Поэтому: Придумывайте для всех аккаунтов надежные и уникальные пароли. Если испытываете трудности с их запоминанием — вам всегда придет на помощь менеджер паролей. Он же поможет их сгенерировать.
Обязательно включайте двухфакторную аутентификацию (одноразовые коды в SMS или приложении) во всех сервисах, которые это позволяют.

13) Что такое IP

IP-адрес (от англ. Internet Protocol) — уникальный числовой идентификатор устройства в компьютерной сети, работающей по протоколу IP.
В сети Интернет требуется глобальная уникальность адреса; в случае работы в локальной сети требуется уникальность адреса в пределах сети. В версии протокола IPv4 IP-адрес имеет длину 4 байта, а в версии протокола IPv6 — 16 байт.

IPv4
Основная статья: IPv4
В 4-й версии IP-адрес представляет собой 32-битное число. Как правило, адрес записывается в виде четырёх десятичных чисел значением от 0 до 255 (эквиваленты четырём восьмибитным числам), разделённых точками, например, 192.168.0.3.

IPv6
Основная статья: IPv6
В 6-й версии IP-адрес является 128-битным. Как правило, адрес записывается в виде восьми четырёхзначных шестнадцатеричных чисел (эквивалентны восьми 16-битным числам), разделённых двоеточиями, например, 2001:0db8:85a3:0000:0000:8a2e:0370:7334. Ведущие нули допускается в записи опускать. Нулевые группы, идущие подряд, могут быть опущены, вместо них ставится двойное двоеточие (fe80:0:0:0:0:0:0:1 можно записать как fe80::1). Более одного такого пропуска в адресе не допускается.

Структура
IP-адрес состоит из двух частей: номера сети и номера узла. В случае изолированной сети её адрес может быть выбран администратором из специально зарезервированных для таких сетей блоков адресов (10.0.0.0/8, 172.16.0.0/12 или 192.168.0.0/16). Для выхода в глобальную сеть необходимо, чтобы был IP из другого блока адресов, либо в локальной сети должен быть сервер, подменяющий внутренний IP-адрес (серый) на внешний IP-адрес (белый), например: proxy server, NAT. Если же сеть должна работать как составная часть Интернета, то адрес сети выдаётся провайдером либо региональным интернет-регистратором (Regional Internet Registry, RIR). Согласно данным на сайте IANA[1], существует пять RIR: ARIN, обслуживающий Северную Америку, а также Багамы, Пуэрто-Рико и Ямайку; APNIC, обслуживающий страны Южной, Восточной и Юго-Восточной Азии, а также Австралии и Океании; AfriNIC, обслуживающий страны Африки и Индийского океана; LACNIC, обслуживающий страны Южной Америки и бассейна Карибского моря; и RIPE NCC, обслуживающий Европу, Центральную Азию, Ближний Восток. Региональные регистраторы получают номера автономных систем и большие блоки адресов у IANA, а затем выдают номера автономных систем и блоки адресов меньшего размера локальным интернет-регистраторам (Local Internet Registries, LIR), обычно являющимся крупными провайдерами.

Номер узла в протоколе IP назначается независимо от локального адреса узла. Маршрутизатор по определению входит сразу в несколько сетей. Поэтому каждый порт маршрутизатора имеет собственный IP-адрес. Конечный узел также может входить в несколько IP-сетей. В этом случае компьютер должен иметь несколько IP-адресов, по числу сетевых связей. Таким образом, IP-адрес характеризует не отдельный компьютер или маршрутизатор, а одно сетевое соединение.

Типы адресации
Есть два способа определения того, сколько бит отводится на маску подсети, а сколько — на IP-адрес.
Изначально использовалась классовая адресация (INET), но со второй половины 90-х годов XX века она была вытеснена бесклассовой адресацией (CIDR), при которой количество адресов в сети определяется маской подсети.

Сравнение
Иногда встречается запись IP-адресов вида «192.168.5.0/24». Данный вид записи заменяет собой указание диапазона IP-адресов. Число после косой черты означает количество единичных разрядов в маске подсети. Для приведённого примера маска подсети будет иметь двоичный вид 11111111 11111111 11111111 00000000 или то же самое в маршрутизаторе десятичном виде: «255.255.255.0». 24 разряда IP-адреса отводятся под номер сети, а остальные 8 разрядов полного адреса — под адреса хостов этой сети, адрес этой сети и широковещательный адрес этой сети. Итого, 192.168.5.0/24 означает диапазон адресов хостов от 192.168.5.1 до 192.168.5.254, а также 192.168.5.0 — адрес сети и 192.168.5.255 — широковещательный адрес сети. Для вычисления адреса сети и широковещательного адреса сети используются формулы:

адрес сети = IP.любого_компьютера_этой_сети AND MASK (адрес сети позволяет определить, что компьютеры в одной сети)
широковещательный адрес сети = IP.любого_компьютера_этой_сети OR NOT(MASK) (широковещательный адрес сети воспринимается всеми компьютерами сети как дополнительный свой адрес, то есть пакет на этот адрес получат все хосты сети как адресованные лично им. Если на сетевой интерфейс хоста, который не является машрутизатором пакетов, попадёт пакет, адресованный не ему, то он будет отброшен).
В некоторых системах адрес сети и широковещательный могут быть поменяны местами (не проверено).

Запись IP-адресов с указанием через слэш маски подсети переменной длины, также называют CIDR, в противоположность обычной записи без указания маски, в операционных системах типа UNIX также именуемой INET.

Особые IP-адреса
В протоколе IP существует несколько соглашений об особой интерпретации IP-адресов: если все двоичные разряды IP-адреса равны 1, то пакет с таким адресом назначения должен рассылаться всем узлам, находящимся в той же сети, что и источник этого пакета. Такая рассылка называется ограниченным широковещательным сообщением (limited broadcast). Если в поле номера узла назначения стоят только единицы, то пакет, имеющий такой адрес, рассылается всем узлам сети с заданным номером сети. Например, в сети 192.168.5.0 с маской подсети 255.255.255.0 пакет с адресом 192.168.5.255 доставляется всем узлам этой сети. Такая рассылка называется широковещательным сообщением (direct broadcast).

Статические (статичные) и динамические IP-адреса
IP-адрес называют статическим (постоянным, неизменяемым), если он назначается пользователем в настройках устройства, либо назначается автоматически при подключении устройства к сети и не может быть присвоен другому устройству.

IP-адрес называют динамическим (непостоянным, изменяемым), если он назначается автоматически при подключении устройства к сети и используется в течение ограниченного промежутка времени, указанного в сервисе назначавшего IP-адрес (DHCP).

Для получения IP-адреса клиент может использовать один из следующих протоколов:
BOOTP (RFC 951) — простой протокол настройки сетевого адреса, ранее использовался для бездисковых станций, ныне вытеснен DHCP.
DHCP (RFC 2131) — наиболее распространённый протокол настройки сетевых параметров.
IPCP (RFC 1332) в рамках протокола PPP (RFC 1661).
Zeroconf (RFC 3927) — протокол настройки сетевого адреса, определения имени, поиск служб.
RARP (RFC 903) Устаревший протокол, использующий обратную логику (из аппаратного адреса — в логический) популярного и поныне в широковещательных сетях протокола ARP. Не поддерживает распространения информации о длине маски (не поддерживает VLSM).
Частные IP-адреса IPv4
Основная статья: IPv4 § Назначения подсетей
Адреса IP, используемые в локальных сетях, относят к частным.

Адреса Intranet:
10.0.0.0/8
172.16.0.0/12
192.168.0.0/16

Адреса для внутреннего использования:
127.0.0.0/8 — используется для коммуникаций внутри хоста (см. localhost).
блок с 169.254.1.0 по 169.254.254.255 (подсеть 169.254.0.0/16 за исключением подсетей 169.254.0.0/24 и 169.254.255.0/24) — используется для автоматической настройки сетевого интерфейса в случае отсутствия DHCP (см. link-local).
Полный список описания сетей для IPv4 представлен в RFC 6890.

Инструменты
В ОС Windows свой IP-адрес можно узнать, набрав ipconfig в командной строке.
В ОС Unix свой IP-адрес можно узнать, набрав ifconfig или ip addr в командной строке.
IP-адрес, соответствующий доменному имени, можно узнать с помощью команды: nslookup example.net или ping example.net
IP-адреса, доменные имена и сайты
Одно доменное имя может преобразовываться поочерёдно в несколько IP‐адресов (для распределения нагрузки).

Одновременно, один IP‐адрес может использоваться для тысяч доменных имён с разными сайтами (тогда при доступе они различаются по доменному имени), что вызывает проблемы при идентификации сайтов по IP‐адресу в целях цензуры.

Также, сервер с одним доменным именем может содержать несколько разных сайтов, а части одного сайта могут быть доступны по разным доменным именам (например, для изоляции cookies и скриптов в целях защиты от атак типа межсайтового скриптинга).

14) Что такое откаты в DNS

DNS (англ. Domain Name System «система доменных имён») — компьютерная распределённая система для получения информации о доменах. Чаще всего используется для получения IP-адреса по имени хоста (компьютера или устройства), получения информации о маршрутизации почты и/или обслуживающих узлах для протоколов в домене (SRV-запись).
Распределённая база данных DNS поддерживается с помощью иерархии DNS-серверов, взаимодействующих по определённому протоколу.

Основой DNS является представление об иерархической структуре имени и зонах. Каждый сервер, отвечающий за имя, может передать ответственность за дальнейшую часть домена другому серверу (с административной точки зрения — другой организации или человеку), что позволяет возложить ответственность за актуальность информации на серверы различных организаций (людей), отвечающих только за «свою» часть доменного имени.

Начиная с 2010 года в систему DNS внедряются средства проверки целостности передаваемых данных, называемые DNS Security Extensions (DNSSEC). Передаваемые данные не шифруются, но их достоверность проверяется криптографическими способами. Внедряемый стандарт DANE обеспечивает передачу средствами DNS достоверной криптографической информации (сертификатов), используемых для установления безопасных и защищённых соединений транспортного и прикладного уровней.

Ключевые характеристики DNS
DNS обладает следующими характеристиками:
Распределённость администрирования. Ответственность за разные части иерархической структуры несут разные люди или организации.
Распределённость хранения информации. Каждый узел сети в обязательном порядке должен хранить только те данные, которые входят в его зону ответственности, и (возможно) адреса корневых DNS-серверов.
Кэширование информации. Узел может хранить некоторое количество данных не из своей зоны ответственности для уменьшения нагрузки на сеть.
Иерархическая структура, в которой все узлы объединены в дерево, и каждый узел может или самостоятельно определять работу нижестоящих узлов, или делегировать (передавать) их другим узлам.
Резервирование. За хранение и обслуживание своих узлов (зон) отвечают (обычно) несколько серверов, разделённые как физически, так и логически, что обеспечивает сохранность данных и продолжение работы даже в случае сбоя одного из узлов.
DNS важна для работы Интернета, так как для соединения с узлом необходима информация о его IP-адресе, а для людей проще запоминать буквенные (обычно осмысленные) адреса, чем последовательность цифр IP-адреса. В некоторых случаях это позволяет использовать виртуальные серверы, например, HTTP-серверы, различая их по имени запроса. Первоначально преобразование между доменными и IP-адресами производилось с использованием специального текстового файла hosts, который составлялся централизованно и автоматически рассылался на каждую из машин в своей локальной сети. С ростом Сети возникла необходимость в эффективном, автоматизированном механизме, которым и стала DNS.

DNS была разработана Полом Мокапетрисом в 1983 году; оригинальное описание механизмов работы содержится в RFC 882 и RFC 883. В 1987 публикация RFC 1034 и RFC 1035 изменила спецификацию DNS и отменила RFC 882, RFC 883 и RFC 973 как устаревшие.

Дополнительные возможности
поддержка динамических обновлений
защита данных (DNSSEC) и транзакций (TSIG)
поддержка различных типов информации

История
Использование более простого и запоминающегося имени вместо числового адреса хоста относится к эпохе ARPANET. Стэнфордский исследовательский институт (теперь SRI International) поддерживал текстовый файл HOSTS.TXT, который сопоставлял имена узлов с числовыми адресами компьютеров в ARPANET. Поддержание числовых адресов, называемых списком присвоенных номеров, было обработано Джоном Постелем в Институте информационных наук Университета Южной Калифорнии (ISI), команда которого тесно сотрудничала с НИИ[1].

Адреса назначались вручную. Чтобы запросить имя хоста и адрес и добавить компьютер в главный файл, пользователи связывались с сетевым информационным центром (NIC) SRI, руководимым Элизабет Фейнлер, по телефону в рабочее время.

К началу 1980-х годов поддержание единой централизованной таблицы хостов стало медленным и громоздким, а развивающейся сети требовалась автоматическая система именования для решения технических и кадровых вопросов. Постел поставил перед собой задачу выработать компромисс между пятью конкурирующими предложениями для решения задачи, сформулированной Полом Мокапетрисом. Мокапетрис вместо этого создал концепцию иерархической системы доменных имен.

Рабочая группа IETF опубликовала оригинальные спецификации в RFC 882 и RFC 883 в ноябре 1983 года.

В 1984 году четыре студента UC Berkeley, Дуглас Терри, Марк Пейнтер, Дэвид Риггл и Сонгниан Чжоу, написали первую версию сервера имен BIND (Berkeley Internet Name Daemon). В 1985 году Кевин Данлэп из DEC существенно пересмотрел реализацию DNS. Майк Карел, Фил Альмквист и Пол Викси поддерживали BIND с тех пор. В начале 1990-х годов BIND был перенесен на платформу Windows NT. Он широко распространен, особенно в Unix-системах, и по-прежнему является наиболее широко используемым программным обеспечением DNS в Интернете.

В ноябре 1987 года были приняты спецификации DNS — RFC 1034 и RFC 1035. После этого были приняты сотни RFC, изменяющих и дополняющих DNS.

Проблемы с безопасностью
Первоначально проблемы безопасности не были основными соображениями при разработке программного обеспечения DNS или любого программного обеспечения для развёртывания в раннем Интернете, поскольку сеть не была открыта для широкой общественности. Однако рост Интернета в коммерческом секторе в 1990-х годах изменил требования к мерам безопасности для защиты целостности данных и аутентификации пользователей.

Несколько уязвимостей были обнаружены и использованы злоумышленниками. Одной из таких проблем является отравление кэша DNS, в котором данные распространяются на кэширующие преобразователи под предлогом того, что они являются авторитетным сервером происхождения, тем самым загрязняя хранилище данных потенциально ложной информацией и длительными сроками действия (время жизни). Впоследствии, запросы легитимных приложений могут быть перенаправлены на сетевые хосты, контролируемые злоумышленником.

DNS-ответы ранее не имели криптографической подписи, что давало возможность для множества вариантов атаки. Современные расширения системы безопасности доменных имен (DNSSEC) изменяют DNS, чтобы добавить поддержку криптографически подписанных ответов. Другие расширения, такие как TSIG, добавляют поддержку криптографической аутентификации между доверенными одноранговыми узлами и обычно используются для авторизации передачи зоны или операций динамического обновления.

Некоторые доменные имена могут использоваться для достижения эффектов спуфинга. Например, paypal.com и paypa1.com — это разные имена, но пользователи могут не различать их в графическом пользовательском интерфейсе в зависимости от выбранного шрифта пользователя. Во многих шрифтах буква l и цифра 1 выглядят очень похожими или даже идентичными. Эта проблема остро стоит в системах, которые поддерживают интернационализированные доменные имена, поскольку многие коды символов в ISO 10646 могут отображаться на типичных экранах компьютеров. Эта уязвимость иногда используется в фишинге.

Для подтверждения результатов DNS также могут использоваться такие методы, как обратный DNS с подтверждением прямых записей, но криптографически достоверными они не являются; при этом не учитывается вариант подмены маршрутной информации (англ. BGP hijacking).

Терминология и принципы работы

Ключевыми понятиями DNS являются:
Доме́н (англ. domain «область») — узел в дереве имён, вместе со всеми подчинёнными ему узлами (если таковые имеются), то есть именованная ветвь или поддерево в дереве имён. Структура доменного имени отражает порядок следования узлов в иерархии; доменное имя читается слева направо от младших доменов к доменам высшего уровня (в порядке повышения значимости): вверху находится корневой домен (имеющий идентификатор «.»(точка)), ниже идут домены первого уровня (доменные зоны), затем — домены второго уровня, третьего и т. д. (например, для адреса ru.wikipedia.org. домен первого уровня — org, второго — wikipedia, третьего — ru). DNS позволяет не указывать точку корневого домена.
Поддомен (англ. subdomain) — подчинённый домен (например, wikipedia.org — поддомен домена org, а ru.wikipedia.org — домена wikipedia.org). Теоретически такое деление может достигать глубины 127 уровней, а каждая метка может содержать до 63 символов, пока общая длина вместе с точками не достигнет 254 символов. Но на практике регистраторы доменных имён используют более строгие ограничения. Например, если у вас есть домен вида mydomain.ru, вы можете создать для него различные поддомены вида mysite1.mydomain.ru, mysite2.mydomain.ru и т. д.
Ресурсная запись — единица хранения и передачи информации в DNS. Каждая ресурсная запись имеет имя (то есть привязана к определённому доменному имени, узлу в дереве имён), тип и поле данных, формат и содержание которого зависит от типа.
Зона — часть дерева доменных имён (включая ресурсные записи), размещаемая как единое целое на некотором сервере доменных имён (DNS-сервере, см. ниже), а чаще — одновременно на нескольких серверах (см. ниже). Целью выделения части дерева в отдельную зону является передача ответственности (см. ниже) за соответствующий домен другому лицу или организации. Это называется делегированием (см. ниже). Как связная часть дерева, зона внутри тоже представляет собой дерево. Если рассматривать пространство имён DNS как структуру из зон, а не отдельных узлов/имён, тоже получается дерево; оправданно говорить о родительских и дочерних зонах, о старших и подчинённых. На практике большинство зон 0-го и 1-го уровня ('.', ru, com, …) состоят из единственного узла, которому непосредственно подчиняются дочерние зоны. В больших корпоративных доменах (2-го и более уровней) иногда встречается образование дополнительных подчинённых уровней без выделения их в дочерние зоны.
Делегирование — операция передачи ответственности за часть дерева доменных имён другому лицу или организации. За счёт делегирования в DNS обеспечивается распределённость администрирования и хранения. Технически делегирование выражается в выделении этой части дерева в отдельную зону, и размещении этой зоны на DNS-сервере (см. ниже), управляемом этим лицом или организацией. При этом в родительскую зону включаются «склеивающие» ресурсные записи (NS и А), содержащие указатели на DNS-сервера дочерней зоны, а вся остальная информация, относящаяся к дочерней зоне, хранится уже на DNS-серверах дочерней зоны.
DNS-сервер — специализированное ПО для обслуживания DNS, а также компьютер, на котором это ПО выполняется. DNS-сервер может быть ответственным за некоторые зоны и/или может перенаправлять запросы вышестоящим серверам.
DNS-клиент — специализированная библиотека (или программа) для работы с DNS. В ряде случаев DNS-сервер выступает в роли DNS-клиента.
Авторитетность (англ. authoritative) — признак размещения зоны на DNS-сервере. Ответы DNS-сервера могут быть двух типов: авторитетные (когда сервер заявляет, что сам отвечает за зону) и неавторитетные (англ. Non-authoritative), когда сервер обрабатывает запрос, и возвращает ответ других серверов. В некоторых случаях вместо передачи запроса дальше DNS-сервер может вернуть уже известное ему (по запросам ранее) значение (режим кеширования).
DNS-запрос (англ. DNS query) — запрос от клиента (или сервера) серверу. Запрос может быть рекурсивным или нерекурсивным (см. Рекурсия).
Система DNS содержит иерархию DNS-серверов, соответствующую иерархии зон. Каждая зона поддерживается как минимум одним авторитетным сервером DNS (от англ. authoritative — авторитетный), на котором расположена информация о домене.

Имя и IP-адрес не тождественны — один IP-адрес может иметь множество имён, что позволяет поддерживать на одном компьютере множество веб-сайтов (это называется виртуальный хостинг). Обратное тоже справедливо — одному имени может быть сопоставлено множество IP-адресов: это позволяет создавать балансировку нагрузки.

Для повышения устойчивости системы используется множество серверов, содержащих идентичную информацию, а в протоколе есть средства, позволяющие поддерживать синхронность информации, расположенной на разных серверах. Существует 13 корневых серверов, их адреса практически не изменяются.[2]

Протокол DNS использует для работы TCP- или UDP-порт 53 для ответов на запросы. Традиционно запросы и ответы отправляются в виде одной UDP-датаграммы. TCP используется, когда размер данных ответа превышает 512 байт, и для AXFR-запросов.

Рекурсия
Термином рекурсия в DNS обозначают алгоритм поведения DNS-сервера: «выполнить от имени клиента полный поиск нужной информации во всей системе DNS, при необходимости обращаясь к другим DNS-серверам».

DNS-запрос может быть рекурсивным — требующим полного поиска, — и нерекурсивным (или итеративным) — не требующим полного поиска.

Аналогично — DNS-сервер может быть рекурсивным (умеющим выполнять полный поиск) и нерекурсивным (не умеющим выполнять полный поиск). Некоторые программы DNS-серверов, например, BIND, можно сконфигурировать так, чтобы запросы одних клиентов выполнялись рекурсивно, а запросы других — нерекурсивно.

При ответе на нерекурсивный запрос, а также при неумении или запрете выполнять рекурсивные запросы, DNS-сервер либо возвращает данные о зоне, за которую он ответственен, либо возвращает ошибку. Настройки нерекурсивного сервера, когда при ответе выдаются адреса серверов, которые обладают большим объёмом информации о запрошенной зоне, чем отвечающий сервер (чаще всего — адреса корневых серверов), являются некорректными, и такой сервер может быть использован для организации DoS-атак.

В случае рекурсивного запроса DNS-сервер опрашивает серверы (в порядке убывания уровня зон в имени), пока не найдёт ответ или не обнаружит, что домен не существует (на практике поиск начинается с наиболее близких к искомому DNS-серверов, если информация о них есть в кэше и не устарела, сервер может не запрашивать другие DNS-серверы).

Рассмотрим на примере работу всей системы.

Предположим, мы набрали в браузере адрес ru.wikipedia.org. Браузер ищет соответствие этого адреса IP-адресу в файле hosts. Если файл не содержит соответствия, то далее браузер спрашивает у сервера DNS: «какой IP-адрес у ru.wikipedia.org»? Однако сервер DNS может ничего не знать не только о запрошенном имени, но и даже обо всём домене wikipedia.org. В этом случае сервер обращается к корневому серверу — например, 198.41.0.4. Этот сервер сообщает — «У меня нет информации о данном адресе, но я знаю, что 204.74.112.1 является ответственным за зону org.» Тогда сервер DNS направляет свой запрос к 204.74.112.1, но тот отвечает «У меня нет информации о данном сервере, но я знаю, что 207.142.131.234 является ответственным за зону wikipedia.org.» Наконец, тот же запрос отправляется к третьему DNS-серверу и получает ответ — IP-адрес, который и передаётся клиенту — браузеру.

В данном случае при разрешении имени, то есть в процессе поиска IP по имени:

браузер отправил известному ему DNS-серверу рекурсивный запрос — в ответ на такой тип запроса сервер обязан вернуть «готовый результат», то есть IP-адрес, либо пустой ответ и код ошибки NXDOMAIN;
DNS-сервер, получивший запрос от браузера, последовательно отправлял нерекурсивные запросы, на которые получал от других DNS-серверов ответы, пока не получил ответ от сервера, ответственного за запрошенную зону;
остальные упоминавшиеся DNS-серверы обрабатывали запросы нерекурсивно (и, скорее всего, не стали бы обрабатывать запросы рекурсивно, даже если бы такое требование стояло в запросе).
Иногда допускается, чтобы запрошенный сервер передавал рекурсивный запрос «вышестоящему» DNS-серверу и дожидался готового ответа.

При рекурсивной обработке запросов все ответы проходят через DNS-сервер, и он получает возможность кэшировать их. Повторный запрос на те же имена обычно не идёт дальше кэша сервера, обращения к другим серверам не происходит вообще. Допустимое время хранения ответов в кэше приходит вместе с ответами (поле TTL ресурсной записи).

Рекурсивные запросы требуют больше ресурсов от сервера (и создают больше трафика), так что обычно принимаются от «известных» владельцу сервера узлов (например, провайдер предоставляет возможность делать рекурсивные запросы только своим клиентам, в корпоративной сети рекурсивные запросы принимаются только из локального сегмента). Нерекурсивные запросы обычно принимаются ото всех узлов сети (и содержательный ответ даётся только на запросы о зоне, которая размещена на узле, на DNS-запрос о других зонах обычно возвращаются адреса других серверов).

Обратный DNS-запрос
Основная статья: Обратный просмотр DNS
DNS используется в первую очередь для преобразования символьных имён в IP-адреса, но он также может выполнять обратный процесс. Для этого используются уже имеющиеся средства DNS. Дело в том, что с записью DNS могут быть сопоставлены различные данные, в том числе и какое-либо символьное имя. Существует специальный домен in-addr.arpa, записи в котором используются для преобразования IP-адресов в символьные имена. Например, для получения DNS-имени для адреса 11.22.33.44 можно запросить у DNS-сервера запись 44.33.22.11.in-addr.arpa, и тот вернёт соответствующее символьное имя. Обратный порядок записи частей IP-адреса объясняется тем, что в IP-адресах старшие биты расположены в начале, а в символьных DNS-именах старшие (находящиеся ближе к корню) части расположены в конце.

Записи DNS
Основная статья: Типы ресурсных записей DNS
Записи DNS, или ресурсные записи (англ. resource records, RR), — единицы хранения и передачи информации в DNS. Каждая ресурсная запись состоит из следующих полей[3]:

имя (NAME) — доменное имя, к которому привязана или которому «принадлежит» данная ресурсная запись,
тип (TYPE) ресурсной записи — определяет формат и назначение данной ресурсной записи,
класс (CLASS) ресурсной записи; теоретически считается, что DNS может использоваться не только с TCP/IP, но и с другими типами сетей, код в поле класс определяет тип сети[3],
TTL (Time To Live) — допустимое время хранения данной ресурсной записи в кэше неответственного DNS-сервера,
длина поля данных (RDLEN),
поле данных (RDATA), формат и содержание которого зависит от типа записи.
Наиболее важные типы DNS-записей:

Запись A (address record) или запись адреса связывает имя хоста с адресом протокола IPv4. Например, запрос A-записи на имя referrals.icann.org вернёт его IPv4-адрес — 192.0.34.164.
Запись AAAA (IPv6 address record) связывает имя хоста с адресом протокола IPv6. Например, запрос AAAA-записи на имя K.ROOT-SERVERS.NET вернёт его IPv6-адрес — 2001:7fd::1.
Запись CNAME (canonical name record) или каноническая запись имени (псевдоним) используется для перенаправления на другое имя.
Запись MX (mail exchange) или почтовый обменник указывает сервер(ы) обмена почтой для данного домена.
Запись NS (name server) указывает на DNS-сервер для данного домена.
Запись PTR (pointer[4][5]) обратная DNS-запись или запись указателя связывает IP-адрес хоста с его каноническим именем. Запрос в домене in-addr.arpa на IP-адрес хоста в reverse-форме вернёт имя (FQDN) данного хоста (см. Обратный DNS-запрос). Например (на момент написания), для IP-адреса 192.0.34.164 запрос записи PTR 164.34.0.192.in-addr.arpa вернёт его каноническое имя referrals.icann.org. В целях уменьшения объёма нежелательной корреспонденции (спама) многие серверы-получатели электронной почты могут проверять наличие PTR-записи для хоста, с которого происходит отправка. В этом случае PTR-запись для IP-адреса должна соответствовать имени отправляющего почтового сервера, которым он представляется в процессе SMTP-сессии.
Запись SOA (Start of Authority) или начальная запись зоны указывает, на каком сервере хранится эталонная информация о данном домене, содержит контактную информацию лица, ответственного за данную зону, тайминги (параметры времени) кеширования зонной информации и взаимодействия DNS-серверов.
SRV-запись (server selection) указывает на серверы для сервисов, используется, в частности, для Jabber и Active Directory.
Зарезервированные доменные имена
Документ RFC 2606 (Reserved Top Level DNS Names — Зарезервированные имена доменов верхнего уровня) определяет названия доменов, которые следует использовать в качестве примеров (например, в документации), а также для тестирования. Кроме example.com, example.org и example.net, в эту группу также входят test, invalid и др.

Интернациональные доменные имена
Доменное имя может состоять только из ограниченного набора ASCII-символов, позволяя набрать адрес домена независимо от языка пользователя. ICANN утвердил основанную на Punycode систему IDNA, преобразующую любую строку в кодировке Unicode в допустимый DNS набор символов.

15) Что такое порт, сколько портов у Linux сервера

Порт (англ. port) — целое неотрицательное число, записываемое в заголовках протоколов транспортного уровня сетевой модели OSI (TCP, UDP, SCTP, DCCP).
Обычно на хосте под управлением ОС в пространстве пользователя исполняется несколько процессов, в каждом из которых выполняется какая-либо программа. В случае если несколько программ используют компьютерную сеть, то ОС периодически получает по сети IP-пакет, предназначенный для одной из программ.

Процесс программы, желающей обмениваться данными по сети, может (например, при создании socket):
запросить у ОС в своё распоряжение порт с определённым номером. ОС может либо предоставить порт с этим номером, либо отказать программе (например, в случае, когда порт с этим номером уже отдан в распоряжение другому процессу);
запросить у ОС в своё распоряжение свободный порт с любым номером. ОС в этом случае сама выберет свободный порт, ещё не занятый никаким процессом, и предоставит его в распоряжение запрашивающей программе.
Обмен данными по сети ведётся между двумя процессами по определённому протоколу. Для установки соединения необходимы:

номер протокола;
два IP-адреса (адрес хоста-отправителя и адрес хоста-получателя для построения маршрута между ними);
два номера порта (порт процесса-отправителя и порт получателя).
Порт процесса-отправителя (источника) может быть постоянным (статическим) или назначаться динамически для каждого нового сеанса связи.

При соединении по протоколу TCP порт процесса-отправителя используется:
операционной системой хоста-получателя для отправки пакета-подтверждения о получении данных;
процессом-получателем для отправки пакета-ответа.
При соединении по протоколу UDP допустимо вместо порта процесса-отправителя указывать число ноль, означающее «порт не указан».

При соединении по протоколу SCTP в рамках ассоциации может использоваться:
несколько портов процесса-отправителя (источника)
несколько портов процесса-получателя.
Так как IP-адрес хоста-отправителя и номер порта процесса-отправителя являются аналогом обратного адреса, записываемого на почтовых конвертах (позволяют получателю отправить ответ отправителю), номер порта процесса-отправителя иногда называют «обратным» портом.

Если на хосте какой‑либо процесс постоянно использует один номер порта (например, процесс программы, реализующей web-сервер, может использовать порт 80 для приёма и передачи данных), говорят, что порт является «открытым».
Термины «открытый порт» и «закрытый порт» (заблокированный) также используются, когда речь идёт о фильтрации сетевого трафика.
Если процесс получил номер порта у ОС («открыл порт») и «держит его открытым» для приёма и передачи данных, говорят, что процесс «прослушивает» (разг. слушает, от англ. listen) порт.
Обычно прослушиванием порта занимается процесс программы, реализующей сервер для какого-либо протокола. Процесс программы, реализующей клиент для того же протокола, часто позволяет ОС указать номер порта для подключения к серверу.
Если хост получит пакет, порт процесса-отправителя называется «удалённым» (англ. remote) портом или "открытым на другом хосте", а порт процесса получателя — «локальным» портом, то есть открытым на текущем хосте. Если хост отправил пакет, порт процесса-отправителя называется «локальным» портом (открытым на текущем хосте), а порт процесса-получателя — «удалённым» портом (открытым на другом хосте).

Номера портов для протоколов прикладного уровня модели TCP/IP (HTTP, SSH и др.) обычно назначаются организацией IANA (англ. internet assigned numbers authority). Однако на практике в целях безопасности номера портов могут выбираться произвольно.
Термин «порт» чаще всего применяется по отношению к протоколам TCP и UDP ввиду популярности этих протоколов. В протоколах SCTP и DCCP используются номера, соответствующие понятию «номер порта» для протоколов TCP и UDP.

В заголовках протоколов TCP и UDP для хранения номеров портов выделены поля размером 16 бит. Для протокола TCP порт с номером 0 зарезервирован и не может использоваться. Для протокола UDP указание порта процесса-отправителя («обратного» порта) не является обязательным, и порт с номером 0 означает отсутствие порта. Таким образом, номер порта — число в диапазоне от 1 до 216-1=65 535.

Примеры использования портов
Электронная почта (e-mail)
На сервере запущены процессы программ, реализующих следующие протоколы:

SMTP — протокол для передачи почты от клиента к серверу и между серверами;
POP, IMAP — протоколы, используемые клиентами для получения почты с сервера.
Процесс программы, реализующей протокол SMTP, обычно «слушает» порт TCP с номером 25 (кратко: «tcp/25»).

Процесс программы, реализующей протокол POP, обычно «слушает» порт TCP с номером 110 (кратко: «tcp/110»).
Процессы могут быть запущены на одном хосте (компьютере). Определение конкретного процесса осуществляется по номеру порта.
Процесс программы-клиента, желающей подключиться к серверу для отправки (SMTP) или получения (POP или IMAP) почты, как правило, получает номер порта динамически.

DHCP
В некоторых случаях использование заранее известных номеров портов является обязательным.
Например, для получения IP-адреса по протоколу DHCP процесс программы-клиента по протоколу UDP отправляет датаграмму с порта 68 (порт процесса-отправителя) на порт 67 (порт процесса-получателя).

Использование в URL-адресах
Номера портов могут указываться в адресах веб-сайтов (URL) или в идентификаторах других ресурсов, доступных в компьютерных сетях (URI). По умолчанию в протоколе HTTP используется порт 80, а в протоколе HTTPS — порт 443. URL вида http://www.example.com:8080/path/ указывает, что веб-ресурс обслуживается веб-сервером на порту 8080.

Состояния порта
Узнать номера активных (выданных процессам операционной системой) портов для протоколов транспортного уровня во многих операционных системах (Windows, Unix-подобных) можно с помощью утилит netstat и nmap (в ОС UNIX и ОС Linux).

Состояния порта, показываемые утилитами netstat и nmap, приведены в таблице.

Состояние порта[1]	Описание
Открыт или прослушивается (англ. open или listen)	Программа-сервер готова принимать подключения программ-клиентов («слушает» порт)
Фильтруется (англ. filtered)	Не удаётся определить, открыт порт или закрыт, возможно, из-за работы файрвола или по иной причине
Закрыт (англ. closed)	ОС ещё не выдала номер порта никакому процессу, но в любой момент может это сделать
Номера портов
Основная статья: Список портов TCP и UDP
Порты TCP не пересекаются с портами UDP: порт 1234 протокола TCP не будет мешать обмену данными по протоколу UDP через порт 1234.

В большинстве UNIX-подобных ОС прослушивание портов с номерами 0—1023 требует особых привилегий (root). Другие номера портов выдаются операционной системой первым запросившим их процессам.
Некоторые популярные программы-анализаторы трафика (например, Wireshark) и сетевые брандмауэры используют общепринятые обозначения номеров портов для определения протокола передачи данных, что не всегда корректно. В некоторых случаях сетевые службы используют нестандартные номера портов или используют номера портов не по заявленному назначению. Например, известны случаи запуска интернет-провайдерами SMTP-серверов на портах 2525 (вместо 25) в целях обеспечения безопасности своих пользователей. Специализированные сайты, например, административные веб-интерфейсы, нередко работают на портах, отличных от стандартных 80 и 443.


16) Уровни OSI

Сетевая модель OSI ( The Open Systems Interconnection model ) — сетевая модель стека (магазина) сетевых протоколов OSI/ISO. Посредством данной модели различные сетевые устройства могут взаимодействовать друг с другом. Модель определяет различные уровни взаимодействия систем. Каждый уровень выполняет определённые функции при таком взаимодействии.

Модель OSI была разработана конце 1970-х годов для поддержания разнообразных методов компьютерных сетей, которые в это время конкурировали за применение в крупных национальных сетевых взаимодействиях во Франции, Великобритании и США. В 1980-х годах она стала рабочим продуктом группы взаимодействия открытых систем Международной организации по стандартизации (ISO). Модель не смогла дать полное описание сети и не получила поддержку архитекторов на заре Интернета, который впоследствии нашел отражение в менее предписывающем TCP/IP, в основном под руководством Инженерного совета Интернета (IETF).

В начале и середине 1970-х годов сеть в основном либо спонсировалась государством (NPL network в Великобритании, ARPANET в США, CYCLADES во Франции), либо разрабатывалась вендорами с использованием собственных стандартов, таких как IBM Systems Network Architecture и Digital Equipment Corporation DECnet. Общественные сети передачи данных только начинали появляться, и в конце 1970-х годов они использовали стандарт X.25.

Экспериментальная система коммутации пакетов в Великобритании примерно в 1973—1975 годах выявила необходимость определения протоколов более высокого уровня. После публикации британского Национального вычислительного центра[en] «Для чего нужны распределенные вычисления», ставшей результатом крупных исследований будущих конфигураций компьютерных систем, Великобритания представила аргументы в пользу создания Международной комиссии по стандартам для охвата этой области на совещании Международной организации по стандартизации (ISO) в Сиднее в марте 1977 года.

С 1977 года ISO реализовала программу по разработке общих стандартов и методов сетевого взаимодействия. Аналогичный процесс развивался в Международном консультационном комитете по телеграфии и телефонии (CCITT). Оба органа разработали документы, определяющие схожие сетевые модели. Модель OSI была впервые определена в исходном виде в Вашингтоне в феврале 1978 года французом Хьюбертом Циммерманом[en], немного доработанный проект стандарта был опубликован ISO в 1980 году.

Разработчикам модели пришлось столкнуться с конкурирующими приоритетами и интересами. Темпы технологических изменений обусловили необходимость определения стандартов, к которым новые системы могли бы сходиться, а не стандартизировать процедуры постфактум, тогда как традиционный подход к разработке стандартов был противоположным[5]. Хотя это и не был сам стандарт, он представлял собой основу, на базе которой можно было бы определить будущие стандарты[6].

В 1983 году документы CCITT и ISO были объединены и таким образом была сформирована базовая эталонная модель взаимосвязи открытых систем, обычно и называемая эталонной моделью взаимосвязи открытых систем (англ. Open Systems Interconnection, OSI) или просто моделью OSI. Объединённый документ был опубликован в 1984 году и ISO — как стандарт ISO 7498, и переименованным CCITT (ныне сектор стандартизации электросвязи Международного союза электросвязи или МСЭ-Т) — как стандарт X. 200.

OSI состояла из двух основных компонентов: абстрактной модели сети, называемой базовой эталонной моделью или семислойной моделью, и набора сетевых протоколов. Основываясь на идее согласованной модели уровней протоколов, определяющей взаимодействие между сетевыми устройствами и программным обеспечением, эталонная модель OSI стала крупным достижением в стандартизации концепций сетевого взаимодействия.

Концепция семислойной модели была описана в работе американца Чарльза Бахмана из компании Honeywell Information Systems[8]. Различные аспекты структуры OSI эволюционировали из опыта работы с сетью NPL, ARPANET, CYCLADES, EIN и International Networking Working Group[en] (IFIP WG6.1). В этой модели система сетевого взаимодействия была разделена на слои. Внутри каждого слоя один или несколько объектов реализовывали его функциональность. Каждая сущность взаимодействовала непосредственно только со слоем, находящимся прямо под ней, и предоставляла средства для использования слоем, находящимся над ней.

OSI таким образом стала попыткой участников отрасли согласовать общие сетевые стандарты для обеспечения совместимости с оборудованием разных производителей[9]. Для больших сетей зачастую поддерживались несколько наборов сетевых протоколов, причем многие устройства не могли взаимодействовать с другими устройствами именно из-за отсутствия общих протоколов.

В конце 1980-х и начале 1990-х годов в плане построения максимально надёжных компьютерных сетей с моделью OSI стал активно конкурировать Набор интернет-протоколов (TCP/IP), который стал широко использоваться в сетях с оборудованием разных производителей для работы в интернете[10][11]. Тем не менее, модель OSI до сих пор используется в качестве эталона для обучения и документации[12].

Концепция
Стандарты
Модель OSI, которая была определена в серии стандартов ISO/IEC 7498, состоит из следующих частей:

ISO/IEC 7498-1 — базовая модель;
ISO/IEC 7498-2 — архитектура безопасности;
ISO/IEC 7498-3 — наименования и адресация;
ISO/IEC 7498-4 — система менеджмента.
ISO/IEC 7498-1 также опубликован в качестве рекомендации МСЭ-Т X.200[13]. Некоторые спецификации протокола также были доступны в рамках серии ITU-T X. Эквивалентные стандарты ISO и ISO/МЭК для модели OSI были доступны в ISO. Не все из них бесплатны[14].

Основные принципы
Протоколы связи позволяют структуре на одном хосте взаимодействовать с соответствующей структурой того же уровня на другом хосте.

На каждом уровне N два объекта обмениваются блоками данных (PDU) с помощью протокола данного уровня на соответствующих устройствах. Каждый PDU содержит блок служебных данных (SDU), связанный с верхним или нижним протоколом.

Обработка данных двумя взаимодействующими OSI-совместимыми устройствами происходит следующим образом:

Передаваемые данные составляются на самом верхнем уровне передающего устройства (уровень N) в протокольный блок данных (PDU).
PDU передается на уровень N-1, где он становится сервисным блоком данных (SDU).
На уровне N-1 SDU объединяется с верхним, нижним или обоими уровнями, создавая слой N-1 PDU. Затем он передается в слой N-2.
Процесс продолжается до достижения самого нижнего уровня, с которого данные передаются на принимающее устройство.
На приемном устройстве данные передаются от самого низкого уровня к самому высокому в виде серии SDU, последовательно удаляясь из верхнего или нижнего колонтитула каждого слоя до достижения самого верхнего уровня, где принимаются последние данные.

В литературе наиболее часто принято начинать описание уровней модели OSI с 7-го уровня, называемого прикладным, на котором пользовательские приложения обращаются к сети. Модель OSI заканчивается 1-м уровнем — физическим, на котором определены стандарты, предъявляемые независимыми производителями к средам передачи данных:

тип передающей среды (медный кабель, оптоволокно, радиоэфир и др.),
тип модуляции сигнала,
сигнальные уровни логических дискретных состояний (нули и единицы).
Любой протокол модели OSI должен взаимодействовать либо с протоколами своего уровня, либо с протоколами на единицу выше и/или ниже своего уровня. Взаимодействия с протоколами своего уровня называются горизонтальными, а с уровнями на единицу выше или ниже — вертикальными. Любой протокол модели OSI может выполнять только функции своего уровня и не может выполнять функций другого уровня, что не выполняется в протоколах альтернативных моделей.

Каждому уровню с некоторой долей условности соответствует свой операнд — логически неделимый элемент данных, которым на отдельном уровне можно оперировать в рамках модели и используемых протоколов: на физическом уровне мельчайшая единица — бит, на канальном уровне информация объединена в кадры, на сетевом — в пакеты , на транспортном — в сегменты, датаграммы. Любой фрагмент данных, логически объединённых для передачи — кадр, пакет, датаграмма — считается сообщением. Именно сообщения в общем виде являются операндами сеансового, представления и прикладного уровней.

К базовым сетевым технологиям относятся физический и канальный уровни.

Прикладной уровень
Основная статья: Прикладной уровень
Прикладной уровень (уровень приложений; англ. application layer) — верхний уровень модели, обеспечивающий взаимодействие пользовательских приложений с сетью:

позволяет приложениям использовать сетевые службы:
удалённый доступ к файлам и базам данных,
пересылка электронной почты;
отвечает за передачу служебной информации;
предоставляет приложениям информацию об ошибках;
формирует запросы к уровню представления.
Протоколы прикладного уровня: RDP, HTTP, SMTP, SNMP, POP3, FTP, XMPP, OSCAR, Modbus, SIP, TELNET и другие.

Определения протокола прикладного уровня и уровня представления очень размыты, и принадлежность протокола к тому или иному уровню, например протокола HTTPS зависит от конечного сервиса который предоставляет приложение.

В том случае если протокол, например HTTPS, используется для просмотра некоей простой интернет страницы через браузер — его можно рассматривать как протокол прикладного уровня. В том же случае если протокол HTTPS используется как низкоуровневый протокол для передачи финансовой информации например по протоколу ISO 8583, то протокол HTTPS будет являться протоколом уровня представления, а протокол ISO 8583 — будет протоколом уровня приложения. То же касается иных протоколов прикладного уровня[источник не указан 385 дней].

Уровень представления
Основная статья: Уровень представления
Уровень представления (англ. presentation layer) обеспечивает преобразование протоколов и кодирование/декодирование данных. Запросы приложений, полученные с прикладного уровня, на уровне представления преобразуются в формат для передачи по сети, а полученные из сети данные преобразуются в формат приложений. На этом уровне может осуществляться сжатие/распаковка или шифрование/дешифрование, а также перенаправление запросов другому сетевому ресурсу, если они не могут быть обработаны локально.

Уровень представлений обычно представляет собой промежуточный протокол для преобразования информации из соседних уровней. Это позволяет осуществлять обмен между приложениями на разнородных компьютерных системах прозрачным для приложений образом. Уровень представлений обеспечивает форматирование и преобразование кода. Форматирование кода используется для того, чтобы гарантировать приложению поступление информации для обработки, которая имела бы для него смысл. При необходимости этот уровень может выполнять перевод из одного формата данных в другой.

Уровень представлений имеет дело не только с форматами и представлением данных, он также занимается структурами данных, которые используются программами. Таким образом, уровень 6 обеспечивает организацию данных при их пересылке.

Чтобы понять, как это работает, представим, что имеются две системы. Одна использует для представления данных расширенный двоичный код обмена информацией EBCDIC, например, это может быть мейнфрейм компании IBM, а другая — американский стандартный код обмена информацией ASCII (его использует большинство других производителей компьютеров). Если этим двум системам необходимо обменяться информацией, то нужен уровень представлений, который выполнит преобразование и осуществит перевод между двумя различными форматами.

Другой функцией, выполняемой на уровне представлений, является шифрование данных, которое применяется в тех случаях, когда необходимо защитить передаваемую информацию от доступа несанкционированными получателями. Чтобы решить эту задачу, процессы и коды, находящиеся на уровне представлений, должны выполнить преобразование данных. На этом уровне существуют и другие подпрограммы, которые сжимают тексты и преобразовывают графические изображения в битовые потоки, так, что они могут передаваться по сети.

Стандарты уровня представлений также определяют способы представления графических изображений. Для этих целей может использоваться формат PICT — формат изображений, применяемый для передачи графики QuickDraw между прогрiiаммами.

Другим форматом представлений является тэгированный формат файлов изображений TIFF, который обычно используется для растровых изображений с высоким разрешением. Следующим стандартом уровня представлений, который может использоваться для графических изображений, является стандарт, разработанный Объединённой экспертной группой по фотографии (Joint Photographic Expert Group); в повседневном пользовании этот стандарт называют просто JPEG.

Существует другая группа стандартов уровня представлений, которая определяет представление звука и кинофрагментов. Сюда входят интерфейс электронных музыкальных инструментов (англ. Musical Instrument Digital Interface, MIDI) для цифрового представления музыки, разработанный Экспертной группой по кинематографии стандарт MPEG, используемый для сжатия и кодирования видеороликов на компакт-дисках, хранения в оцифрованном виде и передачи со скоростями до 1,5 Мбит/с, и QuickTime — стандарт, описывающий звуковые и видео элементы для программ, выполняемых на компьютерах Macintosh и PowerPC.

Протоколы уровня представления: AFP — Apple Filing Protocol, ICA — Independent Computing Architecture, LPP — Lightweight Presentation Protocol, NCP — NetWare Core Protocol, NDR — Network Data Representation, XDR — eXternal Data Representation, X.25 PAD — Packet Assembler/Disassembler Protocol.

Сеансовый уровень
Основная статья: Сеансовый уровень
Сеансовый уровень (англ. session layer) модели обеспечивает поддержание сеанса связи, позволяя приложениям взаимодействовать между собой длительное время. Уровень управляет созданием/завершением сеанса, обменом информацией, синхронизацией задач, определением права на передачу данных и поддержанием сеанса в периоды неактивности приложений.

Протоколы сеансового уровня: H.245 (Call Control Protocol for Multimedia Communication), ISO-SP (OSI Session Layer Protocol (X.225, ISO 8327)), iSNS (Internet Storage Name Service), L2F (Layer 2 Forwarding Protocol), L2TP (Layer 2 Tunneling Protocol), NetBIOS (Network Basic Input Output System), PAP (Password Authentication Protocol), PPTP (Point-to-Point Tunneling Protocol), RPC (Remote Procedure Call Protocol), RTCP (Real-time Transport Control Protocol), SMPP (Short Message Peer-to-Peer), SCP (Session Control Protocol), ZIP (Zone Information Protocol), SDP (Sockets Direct Protocol)…

Транспортный уровень
Основная статья: Транспортный уровень
Транспортный уровень (англ. transport layer) модели предназначен для обеспечения надёжной передачи данных от отправителя к получателю. При этом уровень надёжности может варьироваться в широких пределах. Существует множество классов протоколов транспортного уровня, начиная от протоколов, предоставляющих только основные транспортные функции (например, функции передачи данных без подтверждения приёма), и заканчивая протоколами, которые гарантируют доставку в пункт назначения нескольких пакетов данных в надлежащей последовательности, мультиплексируют несколько потоков данных, обеспечивают механизм управления потоками данных и гарантируют достоверность принятых данных. Например, UDP ограничивается контролем целостности данных в рамках одной датаграммы и не исключает возможности потери пакета целиком или дублирования пакетов, нарушение порядка получения пакетов данных; TCP обеспечивает надёжную непрерывную передачу данных, исключающую потерю данных или нарушение порядка их поступления или дублирования, может перераспределять данные, разбивая большие порции данных на фрагменты и наоборот, склеивая фрагменты в один пакет.

Протоколы транспортного уровня: ATP (AppleTalk Transaction Protocol), CUDP (Cyclic UDP), DCCP (Datagram Congestion Control Protocol), FCP (Fibre Channel Protocol), IL (IL Protocol), NBF (NetBIOS Frames protocol), NCP (NetWare Core Protocol), SCTP (Stream Control Transmission Protocol), SPX (Sequenced Packet Exchange), SST (Structured Stream Transport), TCP (Transmission Control Protocol), UDP (User Datagram Protocol).

Сетевой уровень
Основная статья: Сетевой уровень
Сетевой уровень (англ. network layer) модели предназначен для определения пути передачи данных. Отвечает за трансляцию логических адресов и имён в физические, определение кратчайших маршрутов, коммутацию и маршрутизацию, отслеживание неполадок и «заторов» в сети.

Протоколы сетевого уровня маршрутизируют данные от источника к получателю. Работающие на этом уровне устройства (маршрутизаторы) условно называют устройствами третьего уровня (по номеру уровня в модели OSI).

Протоколы сетевого уровня: IP/IPv4/IPv6 (Internet Protocol), IPX (Internetwork Packet Exchange, протокол межсетевого обмена), X.25 (частично этот протокол реализован на уровне 2), CLNP (сетевой протокол без организации соединений), IPsec (Internet Protocol Security).

Протоколы маршрутизации — RIP (Routing Information Protocol), OSPF (Open Shortest Path First).

Канальный уровень
Основная статья: Канальный уровень
Канальный уровень (англ. data link layer) предназначен для обеспечения взаимодействия сетей на физическом уровне и контроля ошибок, которые могут возникнуть. Полученные с физического уровня данные, представленные в битах, он упаковывает в кадры, проверяет их на целостность и, если нужно, исправляет ошибки (либо формирует повторный запрос повреждённого кадра) и отправляет на сетевой уровень. Канальный уровень может взаимодействовать с одним или несколькими физическими уровнями, контролируя и управляя этим взаимодействием.

Спецификация IEEE 802 разделяет этот уровень на два подуровня: MAC (англ. media access control) регулирует доступ к разделяемой физической среде, LLC (англ. logical link control) обеспечивает обслуживание сетевого уровня.

На этом уровне работают коммутаторы, мосты и другие устройства. Эти устройства используют адресацию второго уровня (по номеру уровня в модели OSI).

Протоколы канального уровня: ARCnet, ATM, Controller Area Network (CAN), Econet, IEEE 802.3 (Ethernet), Ethernet Automatic Protection Switching (EAPS), Fiber Distributed Data Interface (FDDI), Frame Relay, High-Level Data Link Control (HDLC), IEEE 802.2 (предоставляет функции LLC для подуровня IEEE 802 MAC), Link Access Procedures, D channel (LAPD), IEEE 802.11 wireless LAN, LocalTalk, Multiprotocol Label Switching (MPLS), Point-to-Point Protocol (PPP), Point-to-Point Protocol over Ethernet (PPPoE), Serial Line Internet Protocol (SLIP, устарел), StarLan, Token ring, Unidirectional Link Detection[en] (UDLD), x.25, ARP.

При разработке стеков протоколов на этом уровне решаются задачи помехоустойчивого кодирования. К таким способам кодирования относится код Хемминга, блочное кодирование, код Рида — Соломона.

В программировании этот уровень представляет драйвер сетевой платы, в операционных системах имеется программный интерфейс взаимодействия канального и сетевого уровней между собой. Это не новый уровень, а просто реализация модели для конкретной ОС. Примеры таких интерфейсов: ODI (англ.), NDIS, UDI.

Физический уровень
Основная статья: Физический уровень
Физический уровень (англ. physical layer) — нижний уровень модели, который определяет метод передачи данных, представленных в двоичном виде, от одного устройства (компьютера) к другому. Составлением таких методов занимаются разные организации, в том числе: Институт инженеров по электротехнике и электронике, Альянс электронной промышленности, Европейский институт телекоммуникационных стандартов и другие. Осуществляют передачу электрических или оптических сигналов в кабель или в радиоэфир и, соответственно, их приём и преобразование в биты данных в соответствии с методами кодирования цифровых сигналов.

На этом уровне также работают концентраторы, повторители сигнала и медиаконвертеры.

Функции физического уровня реализуются на всех устройствах, подключенных к сети. Со стороны компьютера функции физического уровня выполняются сетевым адаптером или последовательным портом. К физическому уровню относятся физические, электрические и механические интерфейсы между двумя системами. Физический уровень определяет такие виды сред передачи данных как оптоволокно, витая пара, коаксиальный кабель, спутниковый канал передач данных и т. п. Стандартными типами сетевых интерфейсов, относящимися к физическому уровню, являются: V.35, RS-232, RS-485, RJ-11, RJ-45, разъёмы AUI и BNC.

При разработке стеков протоколов на этом уровне решаются задачи синхронизации и линейного кодирования. К таким способам кодирования относится код NRZ, код RZ, MLT-3, PAM5, Манчестер II.

Протоколы физического уровня: IEEE 802.15 (Bluetooth), IRDA, EIA RS-232, EIA-422, EIA-423, RS-449, RS-485, DSL, ISDN, SONET/SDH, 802.11 Wi-Fi, Etherloop, GSM Um radio interface, ITU и ITU-T, TransferJet[en], ARINC 818, G.hn/G.9960, Modbus Plus.

Соответствие модели OSI и других моделей сетевого взаимодействия
Поскольку наиболее востребованными и практически используемыми стали протоколы (например TCP/IP), разработанные с использованием других моделей сетевого взаимодействия, далее необходимо описать возможное включение отдельных протоколов других моделей в различные уровни модели OSI.

Семейство TCP/IP
Семейство TCP/IP имеет три транспортных протокола: TCP, полностью соответствующий OSI, обеспечивающий проверку получения данных; UDP, отвечающий транспортному уровню только наличием порта, обеспечивающий обмен датаграммами между приложениями, не гарантирующий получения данных; и SCTP, разработанный для устранения некоторых недостатков TCP, в который добавлены некоторые новшества. В семействе TCP/IP есть ещё около двухсот протоколов, самым известным из которых является служебный протокол ICMP, используемый для внутренних нужд обеспечения работы; остальные также не являются транспортными протоколами.

Семейство IPX/SPX
В семействе IPX/SPX порты появляются в протоколе сетевого уровня IPX, обеспечивая обмен датаграммами между приложениями (операционная система резервирует часть сокетов для себя). Протокол SPX, в свою очередь, дополняет IPX всеми остальными возможностями транспортного уровня в полном соответствии с OSI.

В качестве адреса хоста ICX использует идентификатор, образованный из четырёхбайтного номера сети (назначаемого маршрутизаторами) и MAC-адреса сетевого адаптера.



17) Хедеры http запросов

Заголовки HTTP (англ. HTTP Headers) — это строки в HTTP-сообщении, содержащие разделённую двоеточием пару имя-значение. Формат заголовков соответствует общему формату заголовков текстовых сетевых сообщений ARPA (см. RFC 822). Заголовки должны отделяться от тела сообщения хотя бы одной пустой строкой.

Все заголовки разделяются на четыре основных группы:
General Headers (рус. Основные заголовки) — должны включаться в любое сообщение клиента и сервера.
Request Headers (рус. Заголовки запроса) — используются только в запросах клиента.
Response Headers (рус. Заголовки ответа) — только для ответов от сервера.
Entity Headers (рус. Заголовки сущности) — сопровождают каждую сущность сообщения.
Именно в таком порядке рекомендуется посылать заголовки получателю.

Общий формат
Название параметра должно состоять минимум из одного печатного символа (ASCII-коды от 33 до 126). Регистр символов в названиях не имеет значения. Заголовки с неизвестными именами должны игнорироваться. После названия сразу должен следовать символ двоеточия.
Значение может содержать любые символы ASCII кроме перевода строки (код 10) и возврата каретки (код 13). Пробельные символы в начале и конце значения обрезаются. Последовательность нескольких пробельных символов внутри значения может восприниматься как один пробел. Регистр символов также не имеет значения (если иное не предусмотрено форматом поля).
Предусматривается размещение значения на нескольких строках (перенос строки). Для указания переноса в начале следующей строки должен находиться хотя бы один пробельный символ.

Заголовки с одинаковыми названиями параметров, но разными значениями могут объединяться в один, только если значение поля представляет из себя разделённый запятыми список. Во всех остальных случаях значения более дальних заголовков должны перекрывать предыдущие. Поэтому прокси-сервера не должны менять порядок следования заголовков в сообщении. При этом порядок элементов списка обычно значения не имеет.

Пример с многострочными значениями и одинаковыми именами заголовков (обратите внимание на регистр символов и пробелы):

content-type: text/html;
charset=windows-1251
Allow: GET, HEAD
Content-Length: 356
ALLOW: GET, OPTIONS
Content-Length:   1984
Правильный компактный вариант преобразования и интерпретации:

Content-Type: text/html;charset=windows-1251
Allow: GET,HEAD,OPTIONS
Content-Length: 1984
В этом случае недопустимо принимать значение Content-Length, равное 356. При объединении значений Allow, чтобы не потерять семантический смысл, была добавлена запятая в конец первого поля и убран бессмысленно дублирующийся элемент «GET».

Применяемые в заголовках структуры
Дата и время
Только дата указывается в заголовках Date, Expires, Last-Modified, If-Modified-Since, If-Unmodified-Since. Дата может присутствовать в заголовках If-Range и Warning.

В HTTP используется три формата:

Fri, 04 Jul 2008 08:42:36 GMT — предпочитаемый формат по RFC 7231, подмножество формата по RFC 5322.
Friday, 04-Jul-08 08:42:36 GMT — формат описанный в устаревшем RFC 850.
Fri Jul 4 08:42:36 2008 — результат функции asctime() языка ANSI C.
RFC 7231 предписывает получателям данных быть готовыми обрабатывать отметки даты и времени во всех трёх форматах, а формировать отметки даты и времени только в предпочитаемом формате.

Время всегда указывается для часового пояса GMT (UTC+0). Год записывается четырьмя цифрами. День, час, минута и секунда дополняются нулями до двух символов. Для названий месяца и дня недели применяются трёхбуквенные стандартные сокращения на английском языке.

Дни недели начиная с понедельника: Mon, Tue, Wed, Thu, Fri, Sat, Sun.

Месяцы с января по декабрь: Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec.

В PHP для преобразования местного времени во время по Гринвичу используется функция gmdate(). Примеры формирования дат для заголовков HTTP:

 // Текущая дата формирования документа:
 header("Date: ".gmdate(DateTime::RFC850));

 // Дата модификации указанного файла:
 $fp = 'data/my-foo.txt'; // путь к файлу
 header("Last-Modified: ".gmdate("D, d M Y H:i:s", filemtime($fp))." GMT");

 // Документ предположительно изменится через час:
 header("Expires: ".gmdate("D, d M Y H:i:s", time() + 3600)." GMT");
 // 3600 - количество секунд относительно текущего момента.
Байтовые диапазоны
При работе с фрагментами содержимого в специальных заголовках используются байтовые диапазоны (англ. byte ranges). В них можно указать как один фрагмент, так и несколько разделяя их запятыми «,». Диапазоны применяются в заголовках Range и Content-Range. В заголовке Accept-Ranges перечисляются только единицы измерения.

В байтовых диапазонах обязательно в начале указываются название единиц измерения за которым следует символ «=». В настоящий момент кроме единиц bytes никакие другие не применяются. За символом «=» располагаются сами диапазоны. Каждый из них является разделённой дефисом «-» парой натуральных чисел или нуля и натурального числа. Первый элемент указывает начальный байт, а второй — конечный. Нумерация в диапазонах начинается с нуля.

Начальный или конечный байт может быть не указан. При отсутствии последнего байта считается что речь идёт о фрагменте от начального байта до конца содержимого. Если отсутствует начало, то номер конечного байта воспринимается как количество запрашиваемых байт от конца содержимого.

Если первый байт больше чем последний, то диапазон считается синтаксически недействительным (англ. syntactically invalid). Поля заголовка, содержащие диапазоны с синтаксически недействительными значениями, игнорируются. Если первый байт выходит за пределы объёма ресурса, то диапазон игнорируется. Если последний байт выходит за пределы содержимого, то диапазон обрезается до конца.

Блок байтовых диапазонов считается выполнимым если в нём содержится хотя бы один доступный диапазон. Если же все диапазоны некорректны или выходят за пределы объёма ресурса, то серверу следует вернуть сообщение со статусом 416 (Requested range not satisfiable).

Примеры (весь объём ресурса — 5000 байт):

bytes=0-255 — фрагмент от 0-го до 255-го байта включительно.
bytes=42-42 — запрос одного 42-го байта.
bytes=4000-7499,1000-2999 — два фрагмента. Так как первый выходит за пределы, то он интерпретируется как «4000-4999».
bytes=3000-,6000-8055 — первый интерпретируется как «3000-4999», а второй игнорируется.
bytes=-400,-9000 — последние 400 байт (от 4600 до 4999), а второй подгоняется под рамки содержимого (от 0 до 4999) обозначая как фрагмент весь объём.
bytes=500-799,600-1023,800-849 — при пересечениях диапазоны могут объединяться в один (от 500 до 1023).
Работа с заголовками
Заголовки в HTML
Язык разметки HTML позволяет задавать необходимые значения заголовков HTTP внутри <HEAD> с помощью тега <META>. При этом название заголовка указывается в атрибуте http-equiv, а значение — в content. Почти всегда выставляется значение заголовка Content-Type с указанием кодировки, чтобы избежать проблем с отображением текста браузером. Также не лишним является указание значения заголовка Content-Language:

<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=windows-1251">
<meta http-equiv="Content-Language" content="ru">
...
