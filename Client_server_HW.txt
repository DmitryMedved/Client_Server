Клиент_Сервер. HW

1) Прочиать проклиент-серверную архитектуру

 Клиент-серверная архитектура - это система, где есть клиент (устройство, которое отправляет запрос) и сервер (устройство, которое запрос принимает,
обрататывает и отдаёт ответ).

  Клиент отвечает за то КАК показать.
  Сервер отвечает за то ЧТО показать.
  
  1. Сервер
  Само понятие сервера обширно:
1) это может быть физический сервер, типо, железного ящика, в котором много железок и лампочек;
2) это может быть некий софт, типо приложения;
3) некая сущность, которая принимает запрос и отвечает на него;
4) это может быть ПК или телефон, если на этих устройствах установлена программа, которая будет принимать запросы.
  Сойдёмся на том, что сервер - это устройство, которое принимает запросы, обрабатывает их и возвращает какой-то результат (это могут быть либо какие-то
данные, либо просто ответ: "Я всё получил, спасибо").
  Задача сервера: сформировать данные, а как их отображать, решает сам клиент.
  
  2. Клиент
  Это приложение или устройство, которое отправляет запрос. ВАЖНО! Что клиент - это не человек, это всё таки устройство/приложение/браузер/телефон/часы/
  домашяя станция/"умный" чайник... Клиентом даже может быть маленький микро-контролёр, который запрашивает данные о погоде.

2) Что такое HTTP и HTTP

HTTP (Hyper Text Transfer Protocol/ Протокол передачи гипертекста)
Чаще всего общение между клиентом и сервером происходит по HTTP-протоколу. Схема выглядит очень просто: клиенты шлют запросы, сервер возвращает ответы.
Можно сказать, что HTTP - это язык клиента и сервера. Также через этот "язык" происходит обмен данными между пользователями.

  Если программа работает по HTTP-протоколу, то это значит, что она:
    - принимает HTTP-запрос;
    - отдаёт HTTP-ответ;
    - запросы отправляются с помощью HTTP-методов и при этом имеют все атрибуты: хедер, боди (боди может и не быть), а сервер на эти запросы отвечает 
статус-кодом.

  Несмотря на свою функциональность, у HTTP есть один главный недостаток - это незащищённость. Данные между пользователями передаются в незащищённом виде, 
поэтому злоумышленник может вмешаться в передачу данных, перехватить их или изменить, поэтому был создан HTTPS-протокол.

  HTTPS (Hyper Text Transfer Protocol Secure)
  Это безопасный протокол передачи данных, который поддерживает шифрование посредством криптографических протоколов SSL и TLS и является расширенной
версией HTTP-протокола.
  Чтобы лучше понять как работает HTTPS, разберём аналогию с проводом, который состоит из двух слоёв: медная сердцевина и оболочка. Медная сердцевина - это
основная часть провода, по которой идёт ток (это HTTP), а оболочка защищает контакты от внешних воздействий (это HTTPS).

3) HTTP-методы

HTTP-метод необходим для того, чтобы сообщить серверу ЧТО мы хотим сделать с данными (получить/добавить/удалить).

  МЕТОДЫ:
  1) GET - это получение информации, GET запрашивает предоставление ресурса, а сами запросы могут ТОЛЬКО извлекать данные;
  2) POST - используется для отправки сущностей к определённому ресурсу. Часто вызывает изменения состояния или какие-то побочные эффекты на сервере;
  3) PUT - заменяет все текущие представления ресурса данными запроса, т.е. это обновление информации, причём обновляются сразу все поля, даже если мы
меняем всего одно;
  4) PATCH - используется для частичного изменения ресурса, например: меняем тольк одно поле без обновления всех остальных полей;
  5) DELETE - удаляет указанный ресурс.
  
  (ТАКЖЕ ЕСТЬ МЕДОДЫ, КОТОРЫЕ ВСТРЕЧАЮТСЯ В РАБОТЕ ОЧЕНЬ РЕДКО (ИЛИ НИКОГДА)):
  
  6) HEAD - запрашивает предоставление ресурса так же как GET, но без тела ответа;
  7) CONNECT - устанавливает "туннель" к серверу или определённому ресурсу;
  8) OPTIONS - используется для описания параметров соединения с ресурсом;
  9) TRACE - выполняет вызов возвращённого текстового сообщения с ресурса.

4) HTTP статус коды сервера

Status (статусы) - это статусы ответов от сервера.

1) 1хх (Information) - это любые статусы, которые начинаются на единицу (100; 101) - это технические статусы, в работе с ними сталкиваются крайне редко (или
никогда).

2) 2хх (Success) - это статусы успешного выполнения операции:
    • 200 (Ок) - так браузер (клиент) понимает, что запрос выполнен успешно;
    • 201 (Created) - такой ответ возвращается, когда мы создаём сущность на сервере, например: нового пользователя, новый заказ;
    • 202 (Accepted) - указывает на то, что запрос получен, но ещё  не обработан.
    
3) 3хх (Redirect) - это информация о том, что сервер был перемещён, например: клиент посылает запрос на сервер, а на месте сервера теперь другая система, 
которая указывает, куда идти, потому что сервер теперь в другом месте. Клиент же, получив статус "300" поймёт, что нужно найти инфу о перемещении (куда ему
нужно идти) и с изначальным запросом сам отправится по другому адресу:
   • 301 - Moved Permanently
   • 302 - Moved Temporarily

4) 4хх (Client Error) - это наиболее широкая группа статусов и она про ошибки клиента. Очень важно понимать, что это не ошибка пользователя, ЭТО ОШИБКА
КЛИЕНТА. Часто 400-е статусы говорят нам, что ЧТО-ТО НЕ ТАК С ЗАПРОСОМ, например: неправильное тело запроса/ ушёл неправильный метод запроса/ пользователю
не хватает прав и т.д.
   • 404 (Not found):
      - не найден ресурс, который мы запрашиваем (это могла бы быть страница, это могло бы быть какое-то изображение над страницей);
      - либо мы пытались обновить информацию о сущности, которой нет, например: мы пытались изменить клиента с ID_5, а такого нет, при этом сервер не
        нашёл то, что мы просим, и это считается ошибкой клиента ("Ты просишь то, чего нет").
   • 400 (Bad Request) - указывает на то, что сервер не смог понять запрос из-за недействительного синтаксиса;
   • 401 (Unauthorised) - для доступа к запрашиваемому ресурсу требуется аутентификация;
   • 403 (Forbidden) - сервер не понял запрос и отказался его авторизовывать (этот статус похож на 404);
   • 405 (Method Not Allowed) - сервер получил определённый запрос с заданным HTTP-методом, смог его распознать, но не позволяет его реализовать, т.к.
   пользователь не получил доступ к клиенту, который сделал запрос;
   • 418 (I'm a teapot) - сообщает о том, что сервер не может приготовить кофе, потому что он чайник. Эта ошибка ссылаетс на Hyper Text Coffee Pot Control
   Protocol (гипертекстовый протокол кофейников), который был первоапрельской шуткой в 1998г.
   
5) 5хх (Server Error) - это внутренние ошибки сервера. Это значит, что сервер принял наш запрос, запрос начал обрабатываться, но что-то внутри сервера пошло
не по плану, например: мы пользуемся калькулятором и отправили серверу задачу "5/0" и тут могут быть 2 варинта развития событий:
- сервер начал выполнять задачу, выпал в ошибку и выдал ответ, что ответ ждать не стоит;
- сервер обратился к базе данных, а база данных по какой-то причине оказалась недоступна. Изначально предполагалось, что сервер возьмёт из базы данные,
обработает их и вернёт клиенту, а на деле сервер ничего не смог взять, попытался обработать и упал с ошибкой, когда он сообщает клиенту, что ответ ждать
не стоит.
!!! Наша задача как тестировщиков, в данном случае, запомнить параметры запроса, который мы отправили (адрес, метод, тело, заголовки, время, когда мы
получили ошибку и всё, что мы настраивали). Все эти данные передаются разработчику.

5) Что такое ядро браузера

Браузер - это софт, где есть ядро или "браузерный движок", именно ядро браузера распознаёт ответ сервера и начинает выполнять преобразование Java Script, 
HTML, parsID и т.д. в удобный и читаемый интерфейс.  

  Если привести аналогию с автомобилем, то ядро браузера - это всё, что находится под капотом. Браузер объединяет перифирию (или API) и предоставляет 
функционал для манипулирования движком, его поведением, а также предоставляет дополнительные сервисы. Ядро браузера выполняет всю "грязную работу": 
загрузку, отрисовку данных, обработку всевозможных рассчётов и т.д.

6) Какие ядра используются

• Blink: Google
  Это самое популярное ядро. Оно входит в состав проекта Chromium. Именно на основе Chromium создают собственные браузеры. Браузеры компаний 
Opera, Яндекс, Ростелеком и другие используют именно этот браузерный движок. Если кратко, то всё что вы создаёте на движке Blink принадлежит Google
(правда, не эксклюзивно), поэтому заявления вроде "у нас есть свой браузер" не совсем правда.
Открытый исходный код, ответвление движка WebKit.

• Gecko: Mozilla
  Это ядро как основа для производителей браузеров большой популярности не имеет.
Активно развивается компанией Mozilla и используется в собственном браузере компании — Firefox. Также используется в браузере Tor Browser, который
обеспечивает анонимное пребывание в сети.
Открытый исходный код.

• WebKit: Apple
  Развивается компанией Apple и используется в собственном браузере компании — Safari. Ранее многие компании использовали в своих разработках WebKit, 
но после покинули проект и переключились на Blink от Google.
Открытый исходный код.

• EdgeHTML: Microsoft
  Движок используется для браузера компании Microsoft под названием Edge, который пришёл на смену Internet Explorer. Это их новый движок. 
Предыдущий Trident (MSHTML) компания прекратила развивать.
Закрытый исходный код.

7) Что такое API

 Само понятие API довольно абстрактное и для того, чтобы его лучше понять, рассмотрим пример аналогии с автомобилем:

  КАК УПРАВЛЯТЬ АВТОМОБИЛЕМ?
  1) Какие действия необходимы, чтобы поехать вперёд?
  2) Что нужно сделать, чтобы поехать назад?
  3) Что нужно сделать, чтобы поехать направо/налево?
  4) Что нужно сделать, чтобы включить дальний свет?

  На все эти вопросы лекго ответить. Но при этом ВАЖНО, что мы не знаем какой именно у нас автомобиль, потому что это не имеет значения, т.к. мы ожидаем
обнаружить в автомобиле конкретный набор ручек, педалей, рычагов, руль и т.д. Так, вот, API - это и есть этот набор ручек, педалей, рычагов, руль и т.д.
Т.е. это те инструменты, которые клиент ожидает увидеть у сервера для того, чтобы манипулировать данными.

  Другими словами, API - язык общения с сервером.

8. Что такое эндпоинты

 Если дословно, то это точки на сервере. Если ещё конкретнее - это ячейки на API сервера, содержащие в себе определённую информацию об определённых страницах
сайта.

  НАПРИМЕР:
  У нас есть сайт mysite.ru, у сайта есть разные страницы: страница авторизации, страница об авторе, страница с иформацией о том, что это за
сайт и для чего он нужен и т.д. Так вот, страница авторизации будет иметь адрес mysite.ru/loginpage, где "loginpage" как раз и будет одним из end-point.
  
  КАК ЭТО РАБОТАЕТ?
  1. Когда мы нажимаем в браузере "loginpage", происходит отправка HTTP-запроса (HTTP-запрос или request) на сервер.
  2. Когда сервер получает запрос в end-point "loginpage", это значит, что на сервере уже есть ячейка-end-point "loginpage" (т.е. при создании mysite.ru
бэкэнд программисты сделали на сервере такую ячейку, куда положили всю информацию о "loginpage" и написали бизнес-логику, которая начинает работать, 
если постучаться конкретно в этот end-point).
  3. Когда от клиента приходит GET-запрос на end-point "loginpage", сервер уже знает что делать: он обращается к файловой системе, достаёт необходимые 
картинки и тексты, HTML, файлы CSS (нужно понимать, что всё вышеперечисленное (картинки, тексты, HTML, файлы CSS) - ЭТО ВСЁ ТЕКСТ, ДАЖЕ КАРТИНКИ).
  4. Когда весь текст прилетает обратно клиенту (т.е. происходит ответ на браузер или response), браузер (клиент) его модифицирует под удобный интерфейс 
для пользователя.
  5. Браузер - это софт, где есть ядро или "браузерный движок", именно ядро браузера распознаёт ответ сервера и начинает выполнять преобразование Java Script, HTML, 
  parsID и т.д. в удобный и читаемый интерфейс.

9) URL (URI, URL, URN)

1. URL (Uniform Resource Locator/ Унифицированный определитель местонахождения ресурса), т.е. это адрес любого сайта в сети (например: https://mysite.ru), 
определяет местонахождение и способ обращения к нему. URL всегда говорит нам КУДА мы направляем запрос (request). В теории, каждый корректный URL ведёт на 
уникальный ресурс.
Основная цель URL: получить адрес и местоположение ресурса.

   URL СОСТОИТ ИЗ:
   1) Протокола (http или https);
   2) Доменного имени (напрмер: в URL https://mysite.ru, доменным именем будет mysite), в качестве альтернативы домена может быть использован IP-адрес, но
запомнить IP сложнее, поэтому это делается редко;
   3) Хоста (это имя компьютера);
   4) Порта;
   5) Пути;
   6) Параметров;
   7) Методов: https://github.com/MariyaGribanova/Client_Server/blob/70e0e8a98dd3d8d0b22a9dd4a4e1391577e1da48/3.%20HTTP%20%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D1%8B
   8) Заголовка;
   9) Боди (тела).

2. URN (Uniform Resource Name/ Унифицированное имя ресурса) - имя ресурса в сети, определяет ТОЛЬКО НАЗВАНИЕ ресурса, но не говорит как к нему подключиться.

3. URI (Uniform Resource Identifier/ Унифицированный идетификатор ресурса). Это либо URL, либо URN, либо URL + URN.
Основная цель URI - идентифицировать ресурс и отличить его от других ресурсов, используя местоположение или имя.

НАПРИМЕР:
URL: https://mysite.ru
URI: https://mysite.ru/loginpage
URN: logipage

10) Идемпотентные методы HTTP

Идемпотентный ("idem" - тот же самый, "potens" - способный) - это свойство объекта или операции при повторном применении операции давать тот же результат, что
и при первом.

  Таким образом, идемпотентные HTTP методы - это методы, которые совершают ИДЕНТИЧНЫЕ запросы на сервер, при этом имеют один и тот же эффект и не изменяют
состояния сервера. Такой запрос может быть сделан один раз или несколько. При нужно понимать, что на сервере всё равно происходят изменения, например: 
сбор статистики + возвращаемые сервером статус-коды могут отличаться. 

  Корректно реализованные методы GET, PUT, HEAD и DELETE идемпотентны (в то время как метод POST вызывает изменения на сервере, поэтому не относится к 
идемпотентным). Также к идемпотентным запросам относятся все безопасные методы (GET, HEAD, OPTIONS) - это все те методы, которые не меняют состояния сервера, 
т.к. приводят к операции "read-only" (только чтение).

11) Безопасные методы HTTP

Это все те методы, которые не меняют состояния сервера, т.е. приводят к операции "read-only" (только чтение).
  Методы GET, HEAD, OPTIONS безопасные. Все безопасные методы являются также идемпотентными.

12) Идентификация, Аутентификация, Авторизация

ИДЕНТИФИКАЦИЯ
  Для начала надо предоставиться, поэтому чаще всего идентификация связана с введением логина: когда мы пытаемся войти в систему и вводим, к примеру, логин, 
сервер берёт этот логин и отправляет базе SQL-запрос: "Существует ли такой пользователь?", база в свою очередь сравнивает логин с имеющимся у неё "журналом 
логинов", и даёт ответ: "Да, такой пользователь существует" - идентификация пройдена, либо база отвечает: "Нет, такого пользователя не существует" - 
идентификация не пройдена.
Например: пользователь хочет зайти в свой аккаунт Google, система сначала запрашивает логин, пользователь его указывает, система распознаёт пользователя как
существующего, идентификация пройдена.

  АУТЕНТИФИКАЦИЯ
  Это проверка подлинности и происходит сразу после введения учётных записей (логина, пароля, одноразового пароля, access token, md5-шифра и многого другого). 
Аутентицикация сопостовляет, например, логин/пароль с учётной записью в базе данных. Когда мы вводим данные учётной записи, сервер обращается к базе данных, 
которая сопоставляет данные (логин/пароль) и отвечает серверу соответствует ли логин паролю.
Например: пользователь идентифицировался в системе Google, следом система запросила ввести пароль, пользователь его вводит, система сопоставлет логин и 
пароль и приходит к выводу, что данные сходятся - аутентификация пройдена. Но, чтобы обезопасить взлом аккаунта, система дополнительно спросит ещё одноразовый
код из SMS или приложения, если пользователь и его правильно введёт, система окончательно согласится с тем, что она настоящий владелец аккаунта - это 
двухфазная аутентификация.

  АВТОРИЗАЦИЯ
  После того как база дала ответ, что по данному логину и паролю доступ совпал и, к примеру, по этим данным есть доступ только к личным данным, сервер вновь 
делает запрос базе данных на эти личные данные, база их отдаёт, сервер забирает эти данные, пакует в JSON, HTML, CSS, JAVA SCRIPT и отдаёт клиенту ТОЛЬКО 
ЛИЧНУЮ СТРАНИЦУ ПОЛЬЗОВАТЕЛЯ. Таким образом, клиент получаетответ пользователя и формирует этот ответ в удобный для пользователя интерфейс личной страницы.

13) Что такое IP

  IP-адрес - является важным компонентом работы интернета. Представляет из себя уникальный адрес, идентифицирующий устройство в интернете или локальной сети. 
"IP" означает "Интернет-протокол". По-сути, IP - это идентификатор (уникальный признак объекта), позволяющий передавать информацию между устройствами в сети, 
содержит в себе информацию о местоположении устройства и обеспечивает его доступность для связи.
  IP-адрес выглядит строка из чисел, разделённых точками (например: 123.456.7.89). Эти адреса не случайны, они рассчитываются математическ и определяются 
Администрацией адресного пространства Интернета (Internet Assigned Numbers Authority, IANA).

14) Что такое октеты в DNS

В адресной строке браузера мы обычно видим адрес сайта в виде слов (например: google.com), но на самом деле google.com и ему подобные - это не адреса, это 
не адреса, а доменные имена, которые придуманы, чтобы пользователям проще было удобнее их запоминать. Настоящие же имена сайтов состоят исключительно из цифр 
(или IP). IP-адрес - это уникальный числовой идентификтор устройства, он позволяет узнать откуда загружается страница с определённого сайта. Получается что 
реальный адрес google.com выглядит так 64.233.165.100, т.е. вся система работает по принципу телефонной книги, где доменное имя служет именем контакта, а 
IP-адрес - номером телефона.

  Вся эта "телефонная книга" должна где-то храниться, поэтому придумали DNS (Domain Name System/ Система доменных имён) - технологию, которая позволяет 
браузеру возможность находить конкретный сайт по его имени, отвечает за хранение и обработку информации о доменных адресах и используется для преобразования 
доменных имён в IP-адреса в момент отправки запроса на сервер. Работу DNS a.k.a "телефонной книги" обеспечивает DNS-сервер.

  НО С АДРЕСАМИ В ИНТЕРНЕТЕ ЕСТЬ ПРОБЛЕМА. ОНИ ЗАКОНЧИЛИСЬ)
  Сейчас большая часть сети работает через IPv4 (Internet Protocol version 4), в этой версии протокола длина IP-адреса всего 4 байта (32 бита), где каждые 
8 бит - это отдельная часть адреса (ЭТО И ЕСТЬ ОКТЕТ). В общем, это всего 2³² (4 294 967 296 вариантов имён на весь интернет), а последний свободный пул 
IP-адресов был распределён ещё в 2010г...

  КАК ЖЕ ИНТЕРНЕТ ПРОДОЛЖАЕТ РАБОТАТЬ?
  На одном IP-адресе может лежать несколько сайтов: когда сервер получает запрос открыть сайт по такому-то IP-адресу, в запросе также указывается доменное 
имя сайта, поэтому на одном IP могут лежать тысячи сайтов. Но это всё равно полностью проблему не решает, например: если ваш сайт делит IP-адрес с каким-то
другим ресурсом, который, к примеру, заблокировали по какой-то причине, то и ваш сайт тоже заблокируют (именно по этой причине во время активных попыток 
блокировки Telegram пострадало очень много других сайтов).

  НО РЕШЕНИЕ ПРОБЛЕМЫ ЕСТЬ
  Это решение - IPv6 (Internet Protocol version 6), т.е. интернет-протокол 6й версии, основное его преимущество в том, что длина адреса в нём не 4 байта как в 
IPv4, а 16 байт, эти дополнительные байты позволяют использовать более 300млн адресов.  

15) Что такое порт, сколько портов у Linux сервера

Зачастую в интернете один и тот же сервер представляет сервисы различного типа (мгновенный обмен сообщениями, файлообменные сети и т.д.), чтобы этот сервер 
мог легко отличать поступающие к нему запросы, клиент автоматически указывает не только IP-адрес сервера, но и тип протокола, а также порт.
  ПОРТ - это число, которое указывается при запросе. 
  Если говорить грубо, то IP - это адрес дома, а порт - это номер квартиры.
  В каждом компьютере, сервере и маршрутизаторе  65 353 портов, с 0 по 1023 - это порты для Windows и Linux, далее с 1024 до 49151 идут свободно используемые 
порты.

16) Уровни OSI

 Семиуровневая модель OSI описывает как работают сетевые устройства. Эта модель описывает процесс передачи данных, который разделили на 7 частей, каждый 
из которых отвечает за выполнение определённой функции:

  1. ФИЗИЧЕСКИЙ УРОВЕНЬ (ИЛИ "УРОВЕНЬ ПРОВОДОВ")
  Здесь происходит передача физических сигналов (токов, света или радио) от источника к получателю. На этом уровне мы оперируем кабелями, контактами в разъёмах,
кодированием единиц и нулей, модуляцией сигнала и т.д. Среди технологий, которые используются на этом уровнем, можно выделить:
  - интернет, который описывает как должны кодироваться сигналы, передаваться по проводам и т.д.;
  - Bluetooth, Wi-Fi, ИК-порт.
  Сетевые устройства, которые относят к этому уровню - это концентраторы и репитеры, т.е. устройства, которые передают сигнал, не вникая в его логику.

  2. КАНАЛЬНЫЙ УРОВЕНЬ
  Допустим,мы получили физический сигнал с первого уровня (набор напряжений разной амплитуды, волн или радиочастот) и теперь настало время всё это закодировать 
в биты, которые компьютер уже сможет понять.  
  На этом уровне проверяются и исправляются ошибки передачи и здесь мы оперируем понятием "Frame" или "Кадр" - это полезные данные, которым добавлена:
  - дополнительная служебная информация (например: адрес отправителя и получателя, т.к. необходимо указывать от кого и кому предназначаются пересылаемые данные);
  - mac-адреса (идентификаторы) состоят из 48 бит и выглядят примерно так: 00:16:52:00:1F:03, они необходимы для того, чтобы идентифицировать устройства в одной 
сети, т.е. mac - адрес устройста на канальном уровне.
  К технологиям, которые используются на этом уровне также относятся:
  - интернет;
  - протоколы: PPP, CDP, MPLS и др.
  Устройства, которые относят к этому уровню: комутаторы и мосты. Это устройства, которые необходимы для передачи нашего фрейма нужному адресату.

  3. СЕТЕВОЙ УРОВЕНЬ
  На этом уровне происходит маршрутизация трафика, например: если мы ходим попасть на определённый сайт, мы с помощью клиента отпавляем серверу DNS-запрос, 
получаем ответ в виде IP-адреа, который клиент подставляет в пакет с IP-адресами. Процесс , когда данные передаются с верхних уровней на нижние называется 
"инкапсуляцией данных", а когда с нижних на верхние - "декапсуляцией". Т.е. данные, приходящие с верхних уровней на каждых последующих уровнях как бы 
кладутся в конверт с полезной информацией, и когда устройство или приложение этого уровня получает конверт, оно знает что с ним делать, благодаря этой 
информации.
  На этом уровне, благодаря протоколу ICMP мы используем утилиту PING, которая помогает нам определить наличие проблем в сети.
  Устройства, которые относятся к этому уровню: маршрутизатор и протоколы маршрутизации (BGP, OSPF, RIP, EIGRP), которые занимаются передачей данных от 
источника к получателю между разными сетями.

  4. ТРАНСПОРТНЫЙ УРОВЕНЬ
  Обеспечивает передачу данных по сети. Предназначен для обеспечения надёжной передачи данных от отправителя к получателю. В жизни разный транспорт 
применяется для разной категории трафика, по аналогии с этим есть 2 протокола передачи данных:
- TCP (Transmission Control Protocol) используется, если трафик чувствителен к потерям, протокол обеспечивает контроль за передачей данных;
- UDP (User Datagram Protocol) используется, когда трафик не чувствителен к потерям (например: просмотр роликов на YouTube).

  5. СЕАНСОВЫЙ УРОВЕНЬ
  Занимается тем, что управляет соединениями (он их разрывает), например: аудио- или видео-конференция, т.к. на этом уровне устанавливается каким кодеком 
будет кодироваться сигнал, причём этот кодек должен присутствовать у обоих пользователей. 

  6. УРОВЕНЬ ПРЕДСТАВЛЕНИЯ
  Здесь происходит преобразование форматов сообщений: кодирование или сжатие (картинка из сервера приходит в видео текста (единиц и нулей), а клиент её уже 
кодирует в приемлемый для пользователя формат, именно этот процесс происходит на "Уровне представления).

  7. УРОВЕНЬ ПРИЛОЖЕНИЙ
  Тут находятся сетевые службы (Telenet, LPD, TFTP, NFS, DNS, DCHP, SNMP, X Window), которые позволяют конечным пользователям пользоваться интернетом. 
Уровень нужен, чтобы приложения имели доступ к сетевым службам (доступ к файлам, пересылки электронной почты, запросы в базы данных). 
  К технологиям, которые используются на этом уровне также относятся:  
  - HTTPS, HTTP, FTP, SMTP. 

17) Хедеры http запросов

 Хедер/Header/Заголовок - это основная часть HTTP-запросов и ответов, они несут важную информацию о браузере клиента, запрошенной странице, сервере и многом 
другом. Эта информация в основном нужна, чтобы понять что делать с данными.
  Важно понимать, что эта информация не задаётся пользователем, это делается автоматически клиентом или серверрм.
  
  Чтобы увидеть хедер HTTP-запроса, необходимо в браузере нажать F12, перейти на вкладку Network, затем на вкладку Fetch/XHR и далее на вкладку Headers. Здесь 
во вкладке General содержится самая важная информация заголовка, мы можем увидеть:
- URL-запрос;
- метод запроса;
- статус-код;
- ответ сервера и др.